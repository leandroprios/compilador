package edu.unnoba.compiladores.compilador_unnoba_2023;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import java.io.FileReader;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.Hashtable;
import edu.unnoba.compiladores.compilador_unnoba_2023.exceptions.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast_expresiones.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast_expresiones_binarias.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast_expresiones_binarias.logicas.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast_expresiones_unarias.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.factor.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.sentencias.*;
import java.util.Iterator;


//crear un metodo de clase que genere un autoincremental
class MiParser;
action code {:
:};

parser code
{:

    Boolean is_asignacion_filter = false;

    Tipo tipo_filter_validate_aux;

    List<String> produccionesRecorridas = new ArrayList<>();
    
    Boolean isAsignacion = false;
    String idAsignacion; 
    String returnFilter;
    ArrayList<String> lista_varFilter = new ArrayList<String>();

    public List<String> getProduccionesList(){
        return this.produccionesRecorridas;
    }
   

    public String printProduccionesRecorridas(List<String> misProducciones){
        String textoConcat = "";
        textoConcat = textoConcat.concat("Pasó por las siguientes reglas:\n");
        for(String txt : misProducciones){
            textoConcat = textoConcat.concat(txt).concat("\n");
        }
        return textoConcat;
    }

    Hashtable<String, Tipo> ht = new Hashtable<String, Tipo>();

    public Hashtable getSymbolTable(){
        return this.ht;
    }

    public void printHt(Hashtable ht){
        ht.forEach((k, v) -> {
            System.out.println("Tabla de simbolos: " + k.toString() + " " + v.toString());
        });
    }
    public String concatHt(Hashtable ht){
        Iterator<String> iterator = ht.keySet().iterator();
        String concatenado = "\nTabla de simbolos:\n";

        while(iterator.hasNext()) {
            String clave = iterator.next();
            String valor = (String) ht.get(clave);
            concatenado += clave.concat(" -> ").concat(valor).concat("\n");
        }
        return concatenado;
    }

    private String s;

    public void syntax_error(Symbol s){
        this.s="Error en la linea "+ (s.right+1)+ " Columna "+ (s.left+1)+ ". Valor simbolo '"
        +s.value+"' . Simbolo n° "+s.sym+ " no reconocido.";
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        this.s="Error en la linea "+ (s.right+1)+ " Columna "+ (s.left+1)+ ". Valor simbolo '"
        +s.value+"' . Simbolo n° "+s.sym+ " no reconocido." ;
    }

    public String getS(){
        return this.s;
    }
:};

terminal String OPERADOR_SUMA, OPERADOR_RESTA, OPERADOR_DIV, OPERADOR_MULTI, PARENTESIS_ABRE, PARENTESIS_CIERRA,LLAVE_ABRE,LLAVE_CIERRA, OPERADOR_IGUAL,
OPERADOR_DISTINTO, OPERADOR_MAYOR, OPERADOR_MENOR, OPERADOR_MENOR_IGUAL, OPERADOR_MAYOR_IGUAL, OPERADOR_AND, OPERADOR_OR, OPERADOR_NOT,
FOR, DO, CORCHETE_ABRE, CORCHETE_CIERRA, COMA, DOS_PUNTOS, PUNTO_COMA, END, BREAK, CONTINUE, INT_TYPE, FLOAT_TYPE,STRING_LITERAL,
BOOLEAN_TYPE, FILTER, DISPLAY, DECLARE_SECTION, END_DECLARE_SECTION, PROGRAM_SECTION, END_PROGRAM_SECTION, CONST_BOOL, CONST_INT, CONST_FLOAT,
VAR, ASIGNACION, INPUT_INT, INPUT_FLOAT, INPUT_BOOL, GUION_BAJO, IF, ELSE, ELIF, THEN;

nonterminal Programa programa;
nonterminal ArrayList<ArrayList<Declaracion>> declaraciones;
nonterminal ArrayList<Declaracion> declaracion;
nonterminal ArrayList<Sentencia> bloque_programa;
nonterminal ArrayList<ArrayList<Declaracion>> bloque_declaraciones;
nonterminal ArrayList<Sentencia> bloque_sentencias;
nonterminal Sentencia sentencia;
nonterminal Sentencia sentencia_for;
nonterminal Sentencia sentencia_if;
nonterminal Sentencia sentencia_asignacion;
nonterminal Sentencia sentencia_display;
nonterminal Expresion expresion_or;
nonterminal Expresion input;
nonterminal Expresion expresion_and;
nonterminal Expresion expresion_not;
nonterminal Expresion comparacion;
nonterminal Expresion expresion_sr;
nonterminal Expresion expresion_md;
nonterminal Expresion menos_unario;
nonterminal Expresion factor;
nonterminal Constante constante;
nonterminal Expresion filter;
nonterminal Expresion input_int;
nonterminal Expresion input_float;
nonterminal Expresion input_bool;
nonterminal IncrementoDecrementoFor expresion_incremento_decremento; 
nonterminal ArrayList<SentenciaElif> sentencia_elseif;
nonterminal ArrayList<String> lista_var;

start with programa;

programa ::= bloque_declaraciones:bd bloque_programa: bp{:
        produccionesRecorridas.add("programa ->");
        new Programa(bp,bd);
    :}
    |
   bloque_programa: bp{:
        produccionesRecorridas.add("programa ->");
        new Programa(bp);
:};


bloque_declaraciones ::= DECLARE_SECTION declaraciones:d END_DECLARE_SECTION{:
        produccionesRecorridas.add("bloque_declaraciones -> DECLARE_SECTION declaraciones END_DECLARE_SECTION");
        RESULT  = d;
:};


declaraciones ::= declaracion:dec declaraciones:decs{:
        produccionesRecorridas.add("declaraciones -> declaracion declaraciones");
        decs.add(dec);
        RESULT = decs;
   :}
   |
   declaracion:dec{:
        produccionesRecorridas.add("declaraciones -> declaracion");
        ArrayList<ArrayList<Declaracion>> declaracionesRegla = new ArrayList<ArrayList<Declaracion>>();
        declaracionesRegla.add(dec);
        RESULT = declaracionesRegla;
        
:};

lista_var::= lista_var:l_v COMA VAR:id{:
        produccionesRecorridas.add("lista_var -> lista_var COMA VAR");
        l_v.add(id);

        RESULT = l_v;
    :}
    |
    VAR:id{:
        produccionesRecorridas.add("lista_var -> VAR");
        ArrayList<String> ident = new ArrayList<String>();
        ident.add(id);
        tipo_filter_validate_aux = ht.get(id);
        RESULT = ident;
:};

declaracion ::= INT_TYPE:tipo DOS_PUNTOS lista_var:l_v PUNTO_COMA{:
        produccionesRecorridas.add("declaracion -> INT_TYPE DOS_PUNTOS lista_var PUNTO_COMA");
        ArrayList<Declaracion> declaraciones = new ArrayList<>();
        for(String i : l_v){
            if(ht.containsKey(i)){
                throw new VarAlreadyExistTSException("La variable "+i+" ya esta definida\n");
            }
            else{
                ht.put(i,Tipo.INTEGER);
                declaraciones.add(new Declaracion(Tipo.INTEGER, new Identificador(i, Tipo.INTEGER)));
            }
        }
        RESULT = declaraciones;
    :}
    |
    FLOAT_TYPE DOS_PUNTOS lista_var:l_v  PUNTO_COMA{:
        produccionesRecorridas.add("declaracion -> FLOAT_TYPE DOS_PUNTOS lista_var PUNTO_COMA");
        ArrayList<Declaracion> declaraciones = new ArrayList<>();
        for(String i : l_v){
            if(ht.containsKey(i)){
                throw new VarAlreadyExistTSException("La variable "+i+" ya esta definida\n");
            }
            else{
                ht.put(i,Tipo.FLOAT);
                declaraciones.add(new Declaracion(Tipo.FLOAT, new Identificador(i, Tipo.FLOAT)));
            }
        }
        RESULT = declaraciones;
    :}
    |
    BOOLEAN_TYPE DOS_PUNTOS lista_var:l_v PUNTO_COMA{:
        produccionesRecorridas.add("declaracion -> BOOLEAN_TYPE DOS_PUNTOS lista_var PUNTO_COMA");
        ArrayList<Declaracion> declaraciones = new ArrayList<>();
        for(String i : l_v){
            if(ht.containsKey(i)){
                throw new VarAlreadyExistTSException("La variable "+i+" ya esta definida\n");
            
            }
            else{
                ht.put(i,Tipo.BOOLEAN);
                declaraciones.add(new Declaracion(Tipo.BOOLEAN, new Identificador(i, Tipo.BOOLEAN)));
                
            }
        }
        RESULT = declaraciones;
:};


bloque_programa ::= PROGRAM_SECTION bloque_sentencias:bs END_PROGRAM_SECTION{:
    produccionesRecorridas.add("bloque_programa -> PROGRAM_SECTION bloque_sentencias END_PROGRAM_SECTION");
    RESULT = bs;
:};


bloque_sentencias ::= bloque_sentencias:bs sentencia:s {:
            produccionesRecorridas.add("bloque_sentencias -> bloque_sentencias:bs sentencia");
            bs.add(s);
            RESULT = bs;
       :}
       |
       sentencia:s {:
            produccionesRecorridas.add("bloque_sentencias -> sentencia");
            ArrayList<Sentencia> sentencias = new ArrayList<>();
            sentencias.add(s);
            RESULT  = sentencias;
:};


sentencia ::= sentencia_for: sf{:
            produccionesRecorridas.add("sentencia -> sentencia_for");
            RESULT = sf;
       :}
       |
       sentencia_if: sif{:
            produccionesRecorridas.add("sentencia -> sentencia_if");
            RESULT = sif;
       :}
       |
       sentencia_asignacion: sa{:
            produccionesRecorridas.add("sentencia -> sentencia_asignacion");
            RESULT = sa;
       :}
       |
       sentencia_display: sd{:
            produccionesRecorridas.add("sentencia -> sentencia_display");
            RESULT = sd;
        :}
        |
        BREAK: b{:
            produccionesRecorridas.add("sentencia -> BREAK");
            RESULT = new Break(); 
        :}
        |
        CONTINUE: c{:
            produccionesRecorridas.add("sentencia -> CONTINUE");
            RESULT = new Continue();
:};


sentencia_asignacion ::= VAR:id ASIGNACION {:

    isAsignacion= true;
    idAsignacion = id;
    :} expresion_or: eo {:
        produccionesRecorridas.add("sentencia_asignacion -> VAR ASIGNACION expresion_or");


        if(!ht.containsKey(id)){
            throw new VarNotDeclaredTSException("La variable "+(String) id+" no está declarada previamente.");
        }
        Tipo tipoId = ht.get(id);
        is_asignacion_filter = true;
        RESULT = new Asignacion(new Identificador(id, tipoId),eo);
:};


expresion_or ::= expresion_or: eo OPERADOR_OR expresion_and :ea{:
        produccionesRecorridas.add("expresion_or -> expresion_or OPERADOR_OR expresion_and");
        if(eo.getTipo() == Tipo.BOOLEAN && ea.getTipo() == Tipo.BOOLEAN){
            RESULT =new Or(eo,ea);
        }
        else{
            throw new Exception("No se puede realizar la expresion OR entre una variable del tipo " + eo.getTipo().toString() + " y una variable de tipo " + ea.getTipo().toString());
        }
       :}
       |
       expresion_and :ea{:
            produccionesRecorridas.add("expresion_or -> expresion_and");
            RESULT = ea; 
:};


expresion_and ::= expresion_and: ea OPERADOR_AND expresion_not :en{:
        produccionesRecorridas.add("expresion_and -> expresion_and OPERADOR_AND expresion_not");
        if(ea.getTipo() == Tipo.BOOLEAN && en.getTipo() == Tipo.BOOLEAN){
            RESULT =new And(ea,en);
        }
        else{
            throw new Exception("No se puede realizar la expresion AND entre una variable del tipo " + ea.getTipo().toString() + " y una variable de tipo " + en.getTipo().toString());
        }
    :}
    |
    expresion_not :en{:
        produccionesRecorridas.add("expresion_and -> expresion_not");
        RESULT = en;
:};


expresion_not ::= OPERADOR_NOT expresion_not :en{:
        produccionesRecorridas.add("expresion_not -> OPERADOR_NOT expresion_not");
        if(en.getTipo() == Tipo.BOOLEAN){
            RESULT =new NegacionLogica(en);
        }
        else{
            throw new Exception("No se puede realizar la expresion NOT con una variable del tipo " + en.getTipo().toString());
        }        
       :}
       |
       comparacion:c{:
        produccionesRecorridas.add("expresion_not -> comparacion");
        RESULT = c;
:};



comparacion ::= expresion_sr :esr1 OPERADOR_MAYOR expresion_sr: esr2{:
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_MAYOR expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                RESULT = new Mayor(esr1,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                RESULT = new Mayor(esr1,flotante);
            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                RESULT = new Mayor(flotante,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                RESULT = new Mayor(esr1,esr2);
            }
            else{
                throw new Exception("La variable de tipo " + esr1.getTipo().toString() + " no puede compararse con el operador > con una variable del tipo " + esr2.getTipo().toString());
            }
       :}
       |
       expresion_sr :esr1 OPERADOR_MAYOR_IGUAL expresion_sr: esr2{:
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_MAYOR_IGUAL expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                RESULT = new MayorIgual(esr1,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                RESULT = new MayorIgual(esr1,flotante);
            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                RESULT = new MayorIgual(flotante,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                RESULT = new MayorIgual(esr1,esr2);
            }
            else{
                throw new Exception("La variable de tipo " + esr1.getTipo().toString() + " no puede compararse con el operador >= con una variable del tipo " + esr2.getTipo().toString());
            }
       :}
       |
       expresion_sr :esr1 OPERADOR_MENOR expresion_sr: esr2{:
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_MENOR expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                RESULT = new Menor(esr1,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                RESULT = new Menor(esr1,flotante);
            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                RESULT = new Menor(flotante,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                RESULT = new Menor(esr1,esr2);
            }
            else{
                throw new Exception("La variable de tipo " + esr1.getTipo().toString() + " no puede compararse con el operador < con una variable del tipo " + esr2.getTipo().toString());
            }
       :}
       |
       expresion_sr :esr1 OPERADOR_MENOR_IGUAL expresion_sr: esr2{:
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_MENOR_IGUAL expresion_s");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                RESULT = new MenorIgual(esr1,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                RESULT = new MenorIgual(esr1,flotante);
            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                RESULT = new MenorIgual(flotante,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                RESULT = new MenorIgual(esr1,esr2);
            }
            else{
                throw new Exception("La variable de tipo " + esr1.getTipo().toString() + " no puede compararse con el operador < con una variable del tipo " + esr2.getTipo().toString());
            }
       :}
       |
       expresion_sr :esr1 OPERADOR_IGUAL expresion_sr: esr2{:
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_IGUAL expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                RESULT = new Igualdad(esr1,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                RESULT = new Igualdad(esr1,flotante);
            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                RESULT = new Igualdad(flotante,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                RESULT = new Igualdad(esr1,esr2);
            }
            else{
                throw new Exception("La variable de tipo " + esr1.getTipo().toString() + " no puede compararse con el operador == con una variable del tipo " + esr2.getTipo().toString());
            }
       :}
       |
       expresion_sr :esr1 OPERADOR_DISTINTO expresion_sr: esr2{:
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_DISTINTO expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                RESULT = new Desigualdad(esr1,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                RESULT = new Desigualdad(esr1,flotante);
            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                RESULT = new Desigualdad(flotante,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                RESULT = new Desigualdad(esr1,esr2);
            }
            else{
                throw new Exception("La variable de tipo " + esr1.getTipo().toString() + " no puede compararse con el operador != con una variable del tipo " + esr2.getTipo().toString());
            }
       :}
       |
       expresion_sr :esr{:
            produccionesRecorridas.add("comparacion -> expresion_sr");
            RESULT = esr;
:};


expresion_sr ::= expresion_sr :esr OPERADOR_SUMA expresion_md: emd{:
            produccionesRecorridas.add("expresion_sr ->expresion_sr OPERADOR_SUMA expresion_md");
             if(esr.getTipo() == Tipo.INTEGER && emd.getTipo() == Tipo.INTEGER){
                RESULT = new Suma(esr,emd , Tipo.INTEGER);
            }
            else if(esr.getTipo() == Tipo.FLOAT && emd.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(emd);
                RESULT = new Suma(esr,flotante, Tipo.FLOAT);
            }
            else if(esr.getTipo() == Tipo.INTEGER && emd.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr);
                RESULT = new Suma(flotante,emd, Tipo.FLOAT);
            }
            else if(esr.getTipo() == Tipo.FLOAT && emd.getTipo() == Tipo.FLOAT){
                RESULT = new Suma(esr,emd, Tipo.FLOAT);
            }
            else{
                throw new Exception("No se puede sumar entre una variable de tipo " + esr.getTipo().toString() + " y una variable de tipo " + emd.getTipo().toString());
            }
       :}
       |
       expresion_sr :esr OPERADOR_RESTA expresion_md: emd{:
            produccionesRecorridas.add("expresion_sr -> expresion_sr OPERADOR_RESTA expresion_md");
            if(esr.getTipo() == Tipo.INTEGER && emd.getTipo() == Tipo.INTEGER){
                RESULT = new Resta(esr,emd , Tipo.INTEGER);
            }
            else if(esr.getTipo() == Tipo.FLOAT && emd.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(emd);
                RESULT = new Resta(esr,flotante, Tipo.FLOAT);
            }
            else if(esr.getTipo() == Tipo.INTEGER && emd.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr);
                RESULT = new Resta(flotante,emd, Tipo.FLOAT);
            }
            else if(esr.getTipo() == Tipo.FLOAT && emd.getTipo() == Tipo.FLOAT){
                RESULT = new Resta(esr,emd, Tipo.FLOAT);
            }
            else{
                throw new Exception("No se puede restar entre una variable de tipo " + esr.getTipo().toString() + " y una variable de tipo " + emd.getTipo().toString());
            }
       :}
       |
       expresion_md :emd{:
            produccionesRecorridas.add("expresion_sr -> expresion_md");
            RESULT = emd;
:};


expresion_md ::= expresion_md :emd OPERADOR_MULTI menos_unario:mu{:
        produccionesRecorridas.add("expresion_md -> expresion_md OPERADOR_MULTI menos_unario");
        if(emd.getTipo() == Tipo.INTEGER && mu.getTipo() == Tipo.INTEGER){
            RESULT = new Multiplicacion(emd,mu, Tipo.INTEGER);
        }
        else if(emd.getTipo() == Tipo.FLOAT && mu.getTipo() == Tipo.INTEGER){
            EnteroAFlotante flotante = new EnteroAFlotante(mu);
            RESULT = new Multiplicacion(emd,flotante, Tipo.FLOAT);
        }
        else if(emd.getTipo() == Tipo.INTEGER && mu.getTipo() == Tipo.FLOAT){
            EnteroAFlotante flotante = new EnteroAFlotante(emd);
            RESULT = new Multiplicacion(flotante,mu, Tipo.FLOAT);
        }
        else if(emd.getTipo() == Tipo.FLOAT && mu.getTipo() == Tipo.FLOAT){
            RESULT = new Multiplicacion(emd,mu, Tipo.FLOAT);
        }
        else{
            throw new Exception("No se puede multiplicar entre una variable de tipo " + emd.getTipo().toString() + " y una variable de tipo " + mu.getTipo().toString());
        }
    :}
    |
    expresion_md :emd OPERADOR_DIV menos_unario:mu{:
        produccionesRecorridas.add("expresion_md -> expresion_md OPERADOR_DIV menos_unario");
        if(emd.getTipo() == Tipo.INTEGER && mu.getTipo() == Tipo.INTEGER){
            RESULT = new Division(emd,mu, Tipo.INTEGER);
        }
        else if(emd.getTipo() == Tipo.FLOAT && mu.getTipo() == Tipo.INTEGER){
            EnteroAFlotante flotante = new EnteroAFlotante(mu);
            RESULT = new Division(emd,flotante, Tipo.FLOAT);
        }
        else if(emd.getTipo() == Tipo.INTEGER && mu.getTipo() == Tipo.FLOAT){
            EnteroAFlotante flotante = new EnteroAFlotante(emd);
            RESULT = new Division(flotante,mu, Tipo.FLOAT);
        }
        else if(emd.getTipo() == Tipo.FLOAT && mu.getTipo() == Tipo.FLOAT){
            RESULT = new Division(emd,mu, Tipo.FLOAT);
        }
        else{
            throw new Exception("No se puede dividir entre una variable de tipo " + emd.getTipo().toString() + " y una variable de tipo " + mu.getTipo().toString());
        }
    :}
    |
    menos_unario:mu{:
        produccionesRecorridas.add("expresion_md -> menos_unario");
        RESULT = mu;
    :};

menos_unario ::= OPERADOR_RESTA menos_unario:mu{:
        produccionesRecorridas.add("menos_unario -> OPERADOR_RESTA menos_unario");
        if(mu.getTipo() == Tipo.INTEGER){
            RESULT =  new NegacionAritmetica(mu,"sub",Tipo.INTEGER);
        }else if(mu.getTipo() == Tipo.FLOAT){
            RESULT =  new NegacionAritmetica(mu,"fsub",Tipo.FLOAT);
        }
        else{
            throw new Exception("No se puede negar una variable de tipo " + mu.getTipo().toString());
        }
    :}
    |
    factor:f {:
        produccionesRecorridas.add("menos_unario -> factor");
        RESULT = f;
:};


factor ::= constante: c{:
        produccionesRecorridas.add("factor -> constante");
        RESULT = c;
       :}
       |
    filter:f{:
        produccionesRecorridas.add("factor -> filter");
        RESULT = f;
    :}
    |
    PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA{:
        produccionesRecorridas.add("factor -> PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA");
        RESULT = eo;
    :}
    |
    GUION_BAJO: gb{:
        produccionesRecorridas.add("factor -> GUION_BAJO");
        RESULT = new GuionBajo();
    :}    
    |
    input: in{:
        produccionesRecorridas.add("factor ->  input");
        RESULT = in;
:};


constante::= CONST_BOOL:bl{:
        produccionesRecorridas.add("constante -> CONST_BOOL");
        RESULT = new Booleano(Boolean.parseBoolean(bl));
    :}
    |
    CONST_INT:il{:
        produccionesRecorridas.add("constante -> CONST_INT");
        RESULT = new Entero(Integer.parseInt(il));
    :}
    |
    CONST_FLOAT:fl{:
        produccionesRecorridas.add("constante -> CONST_FLOAT");
        RESULT = new Flotante(Float.parseFloat(fl));
    :}
    |
    STRING_LITERAL:fl{:
        produccionesRecorridas.add("constante -> STRING_LITERAL");
        RESULT = new StringLiteral(fl);
    :}
    |
    VAR:id{:
        produccionesRecorridas.add("constante -> VAR");
        if(!ht.containsKey(id)){
            throw new VarNotDeclaredTSException("La variable " + id + " no está declarada previamente.");
        }
        Tipo tipoId = ht.get(id);
        RESULT = new Identificador(id, tipoId);
 :};


filter::= FILTER PARENTESIS_ABRE expresion_or:e_o COMA CORCHETE_ABRE lista_var:l_v CORCHETE_CIERRA  PARENTESIS_CIERRA {:
    //validarTiposVariablesConExpresion() ---  validar que todos los tipos de l_V y la expresion sean validos, ej filter (_ != TRUE; [1,2,3]) NO DEBERIA PODER OPERAR.
    
    /*if (validarTiposVariablesConExpresion(e_o, l_v)){
        if(isAsignacion==true){
            if(!validarTiposVariablesConTipoAsignacionId(l_v,idAsignacion)){
                //error
            }
        }
    }*/

    
    if(is_asignacion_filter){
        
        if(tipo_filter_validate_aux.equals(Tipo.BOOLEAN)){
            if(!e_o.getTipo().equals(tipo_filter_validate_aux)){
                throw new Exception("Un tipo de dato de la lista de var del FILTER no conicide");
            } 
        }
        

    }

    

    SentenciaIf sentenciaIf;
    ArrayList<SentenciaElif> sentenciasELIF = new ArrayList<SentenciaElif>();
    ArrayList<Sentencia> sentenciasDentroIF = new ArrayList<>();
    ArrayList<Sentencia> sentenciasDentroELSE = new ArrayList<>();

    Filter filter;
    
    produccionesRecorridas.add("filter -> FILTER PARENTESIS_ABRE expresion_or COMA CORCHETE_ABRE lista_var CORCHETE_CIERRA PARENTESIS_CIERRA");

    
    for(int j =0; j < l_v.size(); j++){
        String i = l_v.get(j);
        if(!ht.containsKey(i)){
            throw new VarNotDeclaredTSException("La variable "+i+" no esta declarada previamente\n");
        }
        else{
            ArrayList<Sentencia> sentenciasDentroELIF = new ArrayList<>();
            Tipo tipoId = ht.get(i);
            
            if(j==0){
                if(isAsignacion==true){
                    Asignacion asignacion = new Asignacion(new Identificador(i, tipoId), e_o); //sentencia dentro del if
                    sentenciasDentroIF.add(asignacion);
                }
            }else if(j == l_v.size()-1){
                if(isAsignacion==true){
                    Asignacion asignacion = new Asignacion(new Identificador(i, tipoId), e_o); //sentencia dentro del if
                    sentenciasDentroELSE.add(asignacion);
                }
                
            }else{
                if(isAsignacion==true){
                    Asignacion asignacion = new Asignacion(new Identificador(i, tipoId), e_o); //sentencia dentro del if
                    sentenciasDentroELIF.add(asignacion);
                }
                sentenciasELIF.add(new SentenciaElif(sentenciasDentroELIF, e_o));
            }
        }
    }
    sentenciaIf = new SentenciaIf(sentenciasDentroIF,e_o,sentenciasELIF, sentenciasDentroELSE);
    filter = new Filter(sentenciaIf);

    RESULT = filter; 
:};

sentencia_display ::= DISPLAY PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA {:
    produccionesRecorridas.add("sentencia_display -> DISPLAY PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA");
    RESULT = new Display(eo);
:};

input ::= input_int:ii {:
        produccionesRecorridas.add("input -> input_int");
        RESULT = ii;
    :}
    |
    input_float:ifl {:
        produccionesRecorridas.add("input -> input_float");
        RESULT = ifl;
    :}
    |
    input_bool:ib {:
        produccionesRecorridas.add("input -> input_bool");
        RESULT = ib;
:};


input_int ::= INPUT_INT PARENTESIS_ABRE PARENTESIS_CIERRA {:
    produccionesRecorridas.add("input_int -> INPUT_INT PARENTESIS_ABRE PARENTESIS_CIERRA");
    RESULT = new Input(Tipo.INTEGER);
:};

input_float ::= INPUT_FLOAT PARENTESIS_ABRE PARENTESIS_CIERRA {:
    produccionesRecorridas.add("input_float -> INPUT_FLOAT PARENTESIS_ABRE PARENTESIS_CIERRA");
    RESULT = new Input(Tipo.FLOAT);
:};

input_bool ::= INPUT_BOOL PARENTESIS_ABRE PARENTESIS_CIERRA {:
    produccionesRecorridas.add("input_bool -> INPUT_BOOL PARENTESIS_ABRE PARENTESIS_CIERRA");
    RESULT = new Input(Tipo.BOOLEAN);
:};

sentencia_if ::= IF PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA THEN bloque_sentencias:bs END {:
        produccionesRecorridas.add("sentencia_if -> IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias END");
        RESULT = new SentenciaIf(bs,eo);
    :}
    |
    IF PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA THEN bloque_sentencias:bs1 ELSE THEN bloque_sentencias:bs2 END{:
        produccionesRecorridas.add("sentencia_if -> IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias ELSE THEN bloque_sentencias END");
        ArrayList<SentenciaElif> sentenciasElif = new ArrayList<>();
        RESULT = new SentenciaIf(bs1,eo, sentenciasElif,bs2);
    :}
    |
    IF PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA THEN bloque_sentencias:bs1 sentencia_elseif: elseif END{:
        produccionesRecorridas.add("sentencia_if -> IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias sentencia_elseif END");
        ArrayList<Sentencia> sentenciasElse = new ArrayList<>();
        RESULT = new SentenciaIf(bs1,eo,elseif, sentenciasElse);
    :}
    |
    IF PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA THEN bloque_sentencias:bs1 sentencia_elseif: elseif ELSE THEN bloque_sentencias:bs2 END{:
        produccionesRecorridas.add("sentencia_if -> IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias sentencia_elseif ELSE THEN bloque_sentencias END");
        RESULT = new SentenciaIf(bs1,eo,elseif, bs2);
:};


sentencia_elseif ::= sentencia_elseif: elseif ELIF PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA THEN bloque_sentencias:bs2{:
        produccionesRecorridas.add("sentencia_elseif -> sentencia_elseif ELIF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias");
        elseif.add(new SentenciaElif(bs2,eo));
        RESULT = elseif;
    :}
    |
    ELIF PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA THEN bloque_sentencias:bs2{:
        produccionesRecorridas.add("sentencia_elseif -> ELIF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias");
        ArrayList<SentenciaElif> listaElif = new ArrayList<>();
        listaElif.add(new SentenciaElif(bs2,eo));
        RESULT = listaElif;
:};


expresion_incremento_decremento ::= OPERADOR_SUMA:op expresion_sr: esr2{:
        produccionesRecorridas.add("expresion_incremento_decremento -> OPERADOR_SUMA expresion_sr");
        RESULT = new IncrementoDecrementoFor(esr2,op,Tipo.INTEGER);
    :}
    |
    OPERADOR_RESTA:op expresion_sr: esr2{:
        produccionesRecorridas.add("expresion_incremento_decremento -> OPERADOR_RESTA expresion_sr");
        RESULT = new IncrementoDecrementoFor(esr2,op,Tipo.INTEGER);
    :}
    | OPERADOR_SUMA:op OPERADOR_SUMA: esr2{:
        produccionesRecorridas.add("expresion_incremento_decremento -> OPERADOR_SUMA OPERADOR_SUMA");
        RESULT = new IncrementoDecrementoFor(null,op,Tipo.INTEGER);
    :}
    | OPERADOR_RESTA:op OPERADOR_RESTA: esr2{:
        produccionesRecorridas.add("expresion_incremento_decremento -> OPERADOR_RESTA OPERADOR_RESTA");
        RESULT = new IncrementoDecrementoFor(null,op,Tipo.INTEGER);
:};

sentencia_for ::= FOR PARENTESIS_ABRE VAR:id1 ASIGNACION CONST_INT  PUNTO_COMA VAR:id2 expresion_incremento_decremento:e_id PUNTO_COMA comparacion:c_f  PARENTESIS_CIERRA DO bloque_sentencias:bs END{:
        
    //Verificar que c_f contenga el mismo id que id1 y id2;
    if(((String) id1).equals((String) id2)){
        if(!ht.containsKey((String) id1)){
            throw new VarNotDeclaredTSException("La variable "+(String) id1+" no está declarada previamente.");
        }
    }else{
        throw new VarForNotEqualException("La variable pasada como parametro al FOR debe ser la misma");
    }

    ArrayList<Sentencia> sentencias = new ArrayList<>();
    produccionesRecorridas.add("sentencia_for -> FOR PARENTESIS_ABRE VAR ASIGNACION CONST_INT PUNTO_COMA VAR expresion_incremento_decremento PUNTO_COMA comparacion PARENTESIS_CIERRA DO bloque_sentencias END");
    Asignacion asignacion = new Asignacion(new Identificador(id1,Tipo.INTEGER),e_id);
    RESULT = new SentenciaFor(c_f,asignacion,e_id,sentencias);  
:};
