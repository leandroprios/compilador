package edu.unnoba.compiladores.compilador_unnoba_2023;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import java.io.FileReader;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.Hashtable;
import edu.unnoba.compiladores.compilador_unnoba_2023.exceptions.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast_expresiones.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast_expresiones_binarias.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast_expresiones_binarias.logicas.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast_expresiones_unarias.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.factor.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.sentencias.*;
import java.util.Iterator;


//crear un metodo de clase que genere un autoincremental
class MiParser;
action code {:
:};

parser code
{:
    Integer autoincrementalAuxFilter = 0;

    boolean is_sentencia_for = false;

    Boolean isGuionBajoFilter = false;

    Boolean isConstante= false;

    Boolean isExpresionFilter = false;

    ArrayList<Filter> pilaFilter = new ArrayList<>();

    ArrayList<Literal> constantesFilter = new ArrayList<>();

    List<String> produccionesRecorridas = new ArrayList<>();
    
    Boolean isAsignacionFilter = false;
    String idAsignacionFilter; 
    String returnFilter;
    ArrayList<String> lista_varFilter = new ArrayList<String>();

    public List<String> getProduccionesList(){
        return this.produccionesRecorridas;
    }

    public boolean validarTiposVariablesConExpresion(String var, Expresion expresion_or){
        boolean retorno=true;
        Tipo tipoAuxVar = ht.get(var);
        if(expresion_or.getTipo() != tipoAuxVar){
            if((expresion_or.getTipo() == Tipo.BOOLEAN && tipoAuxVar == Tipo.INTEGER) || (expresion_or.getTipo() == Tipo.INTEGER && tipoAuxVar ==Tipo.BOOLEAN) || (expresion_or.getTipo() == Tipo.FLOAT && tipoAuxVar ==Tipo.BOOLEAN) || (expresion_or.getTipo() == Tipo.BOOLEAN && tipoAuxVar == Tipo.FLOAT) ){
                retorno = false;
            }
        }
        
        return retorno;
    }
    
    public boolean validarTiposVariablesConTipoAsignacionId(String var){
        boolean retorno = true;
        Tipo tipoIdAsignacion = ht.get(idAsignacionFilter);
        
        Tipo tipoAuxVar = ht.get(var);
        if(tipoIdAsignacion == Tipo.BOOLEAN &&  tipoAuxVar != Tipo.BOOLEAN){
            retorno = false;
        }else if((tipoIdAsignacion == Tipo.INTEGER || tipoIdAsignacion == Tipo.FLOAT) && tipoAuxVar == Tipo.BOOLEAN){
            retorno = false;
        }else if(tipoIdAsignacion == Tipo.INTEGER && (tipoAuxVar == Tipo.BOOLEAN || tipoIdAsignacion == Tipo.FLOAT)){
            retorno = false;
        }
     
        return retorno;
    }

    public Tipo obtenerTipoReturnFilter(ArrayList<String> l_v){
        Tipo tipoReturn = ht.get(idAsignacionFilter);
        if (!isAsignacionFilter){
            for(String auxVar : l_v){
                tipoReturn = ht.get(auxVar);
                if(tipoReturn == Tipo.FLOAT){
                    break;
                }
            }
        }
        return tipoReturn;
    }

    
   

    public String printProduccionesRecorridas(List<String> misProducciones){
        String textoConcat = "";
        textoConcat = textoConcat.concat("Pasó por las siguientes reglas:\n");
        for(String txt : misProducciones){
            textoConcat = textoConcat.concat(txt).concat("\n");
        }
        return textoConcat;
    }

    Hashtable<String, Tipo> ht = new Hashtable<String, Tipo>();

    public Hashtable<String, Tipo> getSymbolTable(){
        return this.ht;
    }

    Hashtable<String, Constante> htValor = new Hashtable<String, Constante>();

    public Hashtable<String, Constante> getValueTable(){
        return this.htValor;
    }

    public void printHt(Hashtable<String, Tipo> ht){
        ht.forEach((k, v) -> {
            System.out.println("Tabla de simbolos: " + k.toString() + " " + Tipo.toString(v));
        });
    }
    public String concatHt(Hashtable<String, Tipo> ht){
        Iterator<String> iterator = ht.keySet().iterator();
        String concatenado = "\nTabla de simbolos:\n";

        while(iterator.hasNext()) {
            String clave = iterator.next();
            Tipo tipo = ht.get(clave);
            concatenado += clave.concat(" -> ").concat(Tipo.toString(tipo)).concat("\n");
        }
        return concatenado;
    }

    private String s;

    public void syntax_error(Symbol s){
        this.s="Error en la linea "+ (s.right+1)+ " Columna "+ (s.left+1)+ ". Valor simbolo '"
        +s.value+"' . Simbolo n° "+s.sym+ " no reconocido.";
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        this.s="Error en la linea "+ (s.right+1)+ " Columna "+ (s.left+1)+ ". Valor simbolo '"
        +s.value+"' . Simbolo n° "+s.sym+ " no reconocido." ;
    }

    public String getS(){
        return this.s;
    }
:};

terminal String OPERADOR_SUMA, OPERADOR_RESTA, OPERADOR_DIV, OPERADOR_MULTI, PARENTESIS_ABRE, PARENTESIS_CIERRA,LLAVE_ABRE,LLAVE_CIERRA, OPERADOR_IGUAL,
OPERADOR_DISTINTO, OPERADOR_MAYOR, OPERADOR_MENOR, OPERADOR_MENOR_IGUAL, OPERADOR_MAYOR_IGUAL, OPERADOR_AND, OPERADOR_OR, OPERADOR_NOT,
FOR, DO, CORCHETE_ABRE, CORCHETE_CIERRA, COMA, DOS_PUNTOS, PUNTO_COMA, END, BREAK, CONTINUE, INT_TYPE, FLOAT_TYPE,STRING_LITERAL,
BOOLEAN_TYPE, FILTER, DISPLAY, DECLARE_SECTION, END_DECLARE_SECTION, PROGRAM_SECTION, END_PROGRAM_SECTION, CONST_BOOL, CONST_INT, CONST_FLOAT,
VAR, ASIGNACION, INPUT_INT, INPUT_FLOAT, INPUT_BOOL, GUION_BAJO, IF, ELSE, ELIF, THEN;

nonterminal Programa programa;
nonterminal ArrayList<ArrayList<Declaracion>> declaraciones;
nonterminal ArrayList<Declaracion> declaracion;
nonterminal ArrayList<Sentencia> bloque_programa;
nonterminal ArrayList<ArrayList<Declaracion>> bloque_declaraciones;
nonterminal ArrayList<Sentencia> bloque_sentencias;
nonterminal Sentencia sentencia;
nonterminal Sentencia sentencia_for;
nonterminal Sentencia sentencia_if;
nonterminal Sentencia sentencia_asignacion;
nonterminal Sentencia sentencia_display;
nonterminal Expresion expresion_or;
nonterminal Expresion input;
nonterminal Expresion expresion_and;
nonterminal Expresion expresion_not;
nonterminal Expresion comparacion;
nonterminal Expresion expresion_sr;
nonterminal Expresion expresion_md;
nonterminal Expresion menos_unario;
nonterminal Expresion factor;
nonterminal Constante constante;
nonterminal Expresion filter;
nonterminal Expresion input_int;
nonterminal Expresion input_float;
nonterminal Expresion input_bool;
nonterminal IncrementoDecrementoFor expresion_incremento_decremento; 
nonterminal ArrayList<SentenciaElif> sentencia_elseif;
nonterminal ArrayList<String> lista_var;

start with programa;

programa ::= bloque_declaraciones:bd bloque_programa: bp{:
        produccionesRecorridas.add("programa ->");
        RESULT = new Programa(bp,bd);
    :}
    |
   bloque_programa: bp{:
        produccionesRecorridas.add("programa ->");
        RESULT = new Programa(bp);
:};


bloque_declaraciones ::= DECLARE_SECTION declaraciones:d END_DECLARE_SECTION{:
        produccionesRecorridas.add("bloque_declaraciones -> DECLARE_SECTION declaraciones END_DECLARE_SECTION");
        RESULT  = d;
:};


declaraciones ::= declaracion:dec declaraciones:decs{:
        produccionesRecorridas.add("declaraciones -> declaracion declaraciones");
        decs.add(dec);
        RESULT = decs;
   :}
   |
   declaracion:dec{:
        produccionesRecorridas.add("declaraciones -> declaracion");
        ArrayList<ArrayList<Declaracion>> declaracionesRegla = new ArrayList<ArrayList<Declaracion>>();
        declaracionesRegla.add(dec);
        RESULT = declaracionesRegla;
        
:};

lista_var::= lista_var:l_v COMA VAR:id{:
        produccionesRecorridas.add("lista_var -> lista_var COMA VAR");
        l_v.add(id);

        RESULT = l_v;
    :}
    |
    VAR:id{:
        produccionesRecorridas.add("lista_var -> VAR");
        ArrayList<String> ident = new ArrayList<String>();
        ident.add(id);
        RESULT = ident;
:};

declaracion ::= INT_TYPE:tipo DOS_PUNTOS lista_var:l_v PUNTO_COMA{:
        produccionesRecorridas.add("declaracion -> INT_TYPE DOS_PUNTOS lista_var PUNTO_COMA");
        ArrayList<Declaracion> declaraciones = new ArrayList<>();
        for(String i : l_v){
            if(ht.containsKey(i)){
                throw new VarAlreadyExistTSException("La variable "+i+" ya esta definida\n");
            }
            else{
                ht.put(i,Tipo.INTEGER);
                declaraciones.add(new Declaracion(Tipo.INTEGER, new Identificador(i, Tipo.INTEGER)));
            }
        }
        RESULT = declaraciones;
    :}
    |
    FLOAT_TYPE DOS_PUNTOS lista_var:l_v  PUNTO_COMA{:
        produccionesRecorridas.add("declaracion -> FLOAT_TYPE DOS_PUNTOS lista_var PUNTO_COMA");
        ArrayList<Declaracion> declaraciones = new ArrayList<>();
        for(String i : l_v){
            if(ht.containsKey(i)){
                throw new VarAlreadyExistTSException("La variable "+i+" ya esta definida\n");
            }
            else{
                ht.put(i,Tipo.FLOAT);
                declaraciones.add(new Declaracion(Tipo.FLOAT, new Identificador(i, Tipo.FLOAT)));
            }
        }
        RESULT = declaraciones;
    :}
    |
    BOOLEAN_TYPE DOS_PUNTOS lista_var:l_v PUNTO_COMA{:
        produccionesRecorridas.add("declaracion -> BOOLEAN_TYPE DOS_PUNTOS lista_var PUNTO_COMA");
        ArrayList<Declaracion> declaraciones = new ArrayList<>();
        for(String i : l_v){
            if(ht.containsKey(i)){
                throw new VarAlreadyExistTSException("La variable "+i+" ya esta definida\n");
            
            }
            else{
                ht.put(i,Tipo.BOOLEAN);
                declaraciones.add(new Declaracion(Tipo.BOOLEAN, new Identificador(i, Tipo.BOOLEAN)));
                
            }
        }
        RESULT = declaraciones;
:};


bloque_programa ::= PROGRAM_SECTION bloque_sentencias:bs END_PROGRAM_SECTION{:
    produccionesRecorridas.add("bloque_programa -> PROGRAM_SECTION bloque_sentencias END_PROGRAM_SECTION");
    RESULT = bs;
:};


bloque_sentencias ::= bloque_sentencias:bs sentencia:s {:
            produccionesRecorridas.add("bloque_sentencias -> bloque_sentencias:bs sentencia");  
            for(Filter filter : pilaFilter){
                System.out.println("bloque_sentencias filter");
                bs.add((Sentencia)filter);
            }
            pilaFilter.clear();
            bs.add(s);
            RESULT = bs;
       :}
       |
       sentencia:s {:
            produccionesRecorridas.add("bloque_sentencias -> sentencia");
            ArrayList<Sentencia> sentencias = new ArrayList<>();
            for(Filter filter : pilaFilter){
                System.out.println("bloque_sentencias filter");
                sentencias.add((Sentencia)filter);
            }
            pilaFilter.clear();
            sentencias.add(s);
            RESULT  = sentencias;
:};


sentencia ::= sentencia_for: sf{:
            is_sentencia_for = true;
            produccionesRecorridas.add("sentencia -> sentencia_for");
            RESULT = sf;
       :}
       |
       sentencia_if: sif{:
            produccionesRecorridas.add("sentencia -> sentencia_if");
            RESULT = sif;
       :}
       |
       sentencia_asignacion: sa{:
            produccionesRecorridas.add("sentencia -> sentencia_asignacion");
            RESULT = sa;
       :}
       |
       sentencia_display: sd{:
            produccionesRecorridas.add("sentencia -> sentencia_display");
            RESULT = sd;
        :}
        |
        BREAK: b{:
            if(!is_sentencia_for){
                throw new Exception("El BREAK no se encuentra dentro del FOR");
            }
            produccionesRecorridas.add("sentencia -> BREAK");
            RESULT = new Break(); 
        :}
        |
        CONTINUE: c{:
            if(!is_sentencia_for){
                throw new Exception("El CONTINUE no se encuentra dentro del FOR");
            }
            produccionesRecorridas.add("sentencia -> CONTINUE");
            RESULT = new Continue();
:};


sentencia_asignacion ::= VAR:id ASIGNACION {:

    isAsignacionFilter= true;
    idAsignacionFilter = id;
    :} expresion_or: eo {:
        produccionesRecorridas.add("sentencia_asignacion -> VAR ASIGNACION expresion_or");


        if(!ht.containsKey(id)){
            throw new VarNotDeclaredTSException("La variable "+(String) id+" no está declarada previamente.");
        }
        Tipo tipoId = ht.get(id);
        RESULT = new Asignacion(new Identificador(id, tipoId),eo);
:};


expresion_or ::= expresion_or: eo OPERADOR_OR expresion_and :ea{:
        produccionesRecorridas.add("expresion_or -> expresion_or OPERADOR_OR expresion_and");

        if(eo.getTipo() == Tipo.BOOLEAN && ea.getTipo() == Tipo.BOOLEAN){
            /*if (isExpresionFilter){
                RESULT =new ExpresionFilter(eo,ea,Tipo.BOOLEAN);
            }else{
                RESULT =new Or(eo,ea);
            }*/
                RESULT =new Or(eo,ea);

        }
        else{
            throw new Exception("No se puede realizar la expresion OR entre una variable del tipo " + Tipo.toString(eo.getTipo()) + " y una variable de tipo " + Tipo.toString(ea.getTipo()));
        }
       :}
       |
       expresion_and :ea{:
            produccionesRecorridas.add("expresion_or -> expresion_and");
            RESULT = ea; 
:};


expresion_and ::= expresion_and: ea OPERADOR_AND expresion_not :en{:
        produccionesRecorridas.add("expresion_and -> expresion_and OPERADOR_AND expresion_not");
        if(ea.getTipo() == Tipo.BOOLEAN && en.getTipo() == Tipo.BOOLEAN){
            /*if (isExpresionFilter){
                RESULT =new ExpresionFilter(ea,en,Tipo.BOOLEAN);
            }else{
                RESULT =new And(ea,en);
            }*/
                RESULT =new And(ea,en);

        }
        else{
            throw new Exception("No se puede realizar la expresion AND entre una variable del tipo " + Tipo.toString(ea.getTipo()) + " y una variable de tipo " + Tipo.toString(en.getTipo()));
        }
    :}
    |
    expresion_not :en{:
        produccionesRecorridas.add("expresion_and -> expresion_not");
        RESULT = en;
:};


expresion_not ::= OPERADOR_NOT expresion_not :en{:
        produccionesRecorridas.add("expresion_not -> OPERADOR_NOT expresion_not");
        if(en.getTipo() == Tipo.BOOLEAN){
            /*if (isExpresionFilter){
                RESULT =new ExpresionFilter(new NegacionLogica(en),en,Tipo.BOOLEAN);
            }else{
                RESULT =new NegacionLogica(en);
            }*/
            RESULT =new NegacionLogica(en);

        }
        else{
            throw new Exception("No se puede realizar la expresion NOT con una variable del tipo " +  Tipo.toString(en.getTipo()));
        }        
       :}
       |
       comparacion:c{:
        produccionesRecorridas.add("expresion_not -> comparacion");
        RESULT = c;
:};



comparacion ::= expresion_sr :esr1 OPERADOR_MAYOR expresion_sr: esr2{:
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_MAYOR expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,Tipo.INTEGER);
                }else{
                    RESULT = new Mayor(esr1,esr2);
                }*/
                    RESULT = new Mayor(esr1,esr2);

            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,flotante,Tipo.FLOAT);
                }else{
                    RESULT = new Mayor(esr1,flotante);
                }*/
                    RESULT = new Mayor(esr1,flotante);

            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(flotante,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new Mayor(flotante,esr2);
                }*/
                    RESULT = new Mayor(flotante,esr2);


            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new Mayor(esr1,esr2);
                }*/
                    RESULT = new Mayor(esr1,esr2);

            }
            else if(isGuionBajoFilter && (esr2.getTipo() == Tipo.FLOAT || esr2.getTipo() == Tipo.INTEGER)){
                esr1.setTipo(esr2.getTipo());
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,esr2.getTipo());
                }else{
                    RESULT = new Mayor(esr1,esr2);
                }*/
                    RESULT = new Mayor(esr1,esr2);

            }
            else{
                throw new Exception("La variable de tipo " + Tipo.toString(esr1.getTipo()) + " no puede compararse con el operador > con una variable del tipo " + Tipo.toString(esr2.getTipo()));
            }
       :}
       |
       expresion_sr :esr1 OPERADOR_MAYOR_IGUAL expresion_sr: esr2{:
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_MAYOR_IGUAL expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){          
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,Tipo.INTEGER);
                }else{
                    RESULT = new MayorIgual(esr1,esr2);
                }*/
                    RESULT = new MayorIgual(esr1,esr2);

            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,flotante,Tipo.FLOAT);
                }else{
                    RESULT = new MayorIgual(esr1,flotante);
                }*/
                    RESULT = new MayorIgual(esr1,flotante);

            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(flotante,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new MayorIgual(flotante,esr2);
                }*/
                    RESULT = new MayorIgual(flotante,esr2);

            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new MayorIgual(esr1,esr2);
                }*/
                    RESULT = new MayorIgual(esr1,esr2);

            }
            else if(isGuionBajoFilter && (esr2.getTipo() == Tipo.FLOAT || esr2.getTipo() == Tipo.INTEGER)){
                esr1.setTipo(esr2.getTipo());
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,esr2.getTipo());
                }else{
                    RESULT = new MayorIgual(esr1,esr2);
                }*/
                    RESULT = new MayorIgual(esr1,esr2);

            }
            else{
                throw new Exception("La variable de tipo " + Tipo.toString(esr1.getTipo()) + " no puede compararse con el operador >= con una variable del tipo " + Tipo.toString(esr2.getTipo()));
            }
       :}
       |
       expresion_sr :esr1 OPERADOR_MENOR expresion_sr: esr2{:
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_MENOR expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,Tipo.INTEGER);
                }else{
                    RESULT = new Menor(esr1,esr2);
                }*/
                    RESULT = new Menor(esr1,esr2);

            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,flotante,Tipo.FLOAT);
                }else{
                    RESULT = new Menor(esr1,flotante);
                }*/
                    RESULT = new Menor(esr1,flotante);

            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(flotante,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new Menor(flotante,esr2);
                }*/
                    RESULT = new Menor(flotante,esr2);

            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new Menor(esr1,esr2);
                }*/
                    RESULT = new Menor(esr1,esr2);

            }
            else if(isGuionBajoFilter && (esr2.getTipo() == Tipo.FLOAT || esr2.getTipo() == Tipo.INTEGER)){
                esr1.setTipo(esr2.getTipo());
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,esr2.getTipo());
                }else{
                    RESULT = new Menor(esr1,esr2);
                }*/
                    RESULT = new Menor(esr1,esr2);

            }
            else{
                throw new Exception("La variable de tipo " + Tipo.toString(esr1.getTipo()) + " no puede compararse con el operador < con una variable del tipo " + Tipo.toString(esr2.getTipo()));
            }
       :}
       |
       expresion_sr :esr1 OPERADOR_MENOR_IGUAL expresion_sr: esr2{:
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_MENOR_IGUAL expresion_s");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,Tipo.INTEGER);
                }else{
                    RESULT = new MenorIgual(esr1,esr2);
                }*/
                    RESULT = new MenorIgual(esr1,esr2);

            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,flotante,Tipo.FLOAT);
                }else{
                    RESULT = new MenorIgual(esr1,flotante);
                }*/
                    RESULT = new MenorIgual(esr1,flotante);

            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(flotante,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new MenorIgual(flotante,esr2);
                }*/
                    RESULT = new MenorIgual(flotante,esr2);

            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new MenorIgual(esr1,esr2);
                }*/
                    RESULT = new MenorIgual(esr1,esr2);

            }
            else if(isGuionBajoFilter && (esr2.getTipo() == Tipo.FLOAT || esr2.getTipo() == Tipo.INTEGER)){
                esr1.setTipo(esr2.getTipo());
                /*if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,esr2.getTipo());
                }else{
                    RESULT = new MenorIgual(esr1,esr2);                
                }*/
                    RESULT = new MenorIgual(esr1,esr2);                

            }
            else{
                throw new Exception("La variable de tipo " + Tipo.toString(esr1.getTipo()) + " no puede compararse con el operador < con una variable del tipo " + Tipo.toString(esr2.getTipo()));
            }
       :}
       |
       expresion_sr :esr1 OPERADOR_IGUAL expresion_sr: esr2{:
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_IGUAL expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,esr2,Tipo.INTEGER);
                }else{
                    RESULT = new Igualdad(esr1,esr2);
                }*/
                    RESULT = new Igualdad(esr1,esr2);

            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,flotante,Tipo.FLOAT);
                }else{
                    RESULT = new Igualdad(esr1,flotante);
                }*/
                    RESULT = new Igualdad(esr1,flotante);

            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(flotante,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new Igualdad(flotante,esr2);
                }*/
                    RESULT = new Igualdad(flotante,esr2);

            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new Igualdad(esr1,esr2);
                }*/
                    RESULT = new Igualdad(esr1,esr2);

            }
            else if(esr1.getTipo() == Tipo.BOOLEAN && esr2.getTipo() == Tipo.BOOLEAN){
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,esr2,Tipo.BOOLEAN);
                }else{
                    RESULT = new Igualdad(esr1,esr2);
                }*/
                    RESULT = new Igualdad(esr1,esr2);

            }
            else if(isGuionBajoFilter && (esr2.getTipo() == Tipo.FLOAT || esr2.getTipo() == Tipo.INTEGER || esr2.getTipo() == Tipo.BOOLEAN)){
                esr1.setTipo(esr2.getTipo());
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,esr2,esr2.getTipo());
                }else{
                    RESULT = new Igualdad(esr1,esr2);
                }*/
                    RESULT = new Igualdad(esr1,esr2);

            }
            else{
                throw new Exception("La variable de tipo " + Tipo.toString(esr1.getTipo()) + " no puede compararse con el operador == con una variable del tipo " + Tipo.toString(esr2.getTipo()));
            }
       :}
       |
       expresion_sr :esr1 OPERADOR_DISTINTO expresion_sr: esr2{:
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_DISTINTO expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,esr2,Tipo.INTEGER);
                }else{
                    RESULT = new Desigualdad(esr1,esr2);
                }*/
                    RESULT = new Desigualdad(esr1,esr2);

            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,flotante,Tipo.FLOAT);
                }else{
                    RESULT = new Desigualdad(esr1,flotante);
                }*/
                    RESULT = new Desigualdad(esr1,flotante);

            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(flotante,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new Desigualdad(flotante,esr2);
                }*/
                    RESULT = new Desigualdad(flotante,esr2);

            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new Desigualdad(esr1,esr2);
                }*/
                    RESULT = new Desigualdad(esr1,esr2);

            }
            else if(esr1.getTipo() == Tipo.BOOLEAN && esr2.getTipo() == Tipo.BOOLEAN){
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,esr2,Tipo.BOOLEAN);
                }else{
                    RESULT = new Desigualdad(esr1,esr2);
                }*/
                    RESULT = new Desigualdad(esr1,esr2);

            }
            else if(isGuionBajoFilter && (esr2.getTipo() == Tipo.FLOAT || esr2.getTipo() == Tipo.INTEGER || esr2.getTipo() == Tipo.BOOLEAN)){
                esr1.setTipo(esr2.getTipo());
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,esr2,esr2.getTipo());
                }else{
                    RESULT = new Desigualdad(esr1,esr2);
                }*/
                    RESULT = new Desigualdad(esr1,esr2);

            }
            else{
                throw new Exception("La variable de tipo " + Tipo.toString(esr1.getTipo()) + " no puede compararse con el operador != con una variable del tipo " + Tipo.toString(esr2.getTipo()));
            }
       :}
       |
       expresion_sr :esr{:
            produccionesRecorridas.add("comparacion -> expresion_sr");
            RESULT = esr;
:};


expresion_sr ::= expresion_sr :esr OPERADOR_SUMA expresion_md: emd{:
            produccionesRecorridas.add("expresion_sr ->expresion_sr OPERADOR_SUMA expresion_md");
             if(esr.getTipo() == Tipo.INTEGER && emd.getTipo() == Tipo.INTEGER){
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr,emd,Tipo.INTEGER);
                }else{
                    RESULT = new Suma(esr,emd , Tipo.INTEGER);
                };
            }
            else if(esr.getTipo() == Tipo.FLOAT && emd.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(emd);
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr,flotante,Tipo.FLOAT);
                }else{
                    RESULT = new Suma(esr,flotante , Tipo.FLOAT);
                }*/
                    RESULT = new Suma(esr,flotante , Tipo.FLOAT);

            }
            else if(esr.getTipo() == Tipo.INTEGER && emd.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr);
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(flotante,emd,Tipo.FLOAT);
                }else{
                    RESULT = new Suma(flotante,emd, Tipo.FLOAT);
                }*/
                    RESULT = new Suma(flotante,emd, Tipo.FLOAT);

            }
            else if(esr.getTipo() == Tipo.FLOAT && emd.getTipo() == Tipo.FLOAT){
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr,emd,Tipo.FLOAT);
                }else{
                    RESULT = new Suma(esr,emd, Tipo.FLOAT);
                }*/
                    RESULT = new Suma(esr,emd, Tipo.FLOAT);

            }
            else if(isGuionBajoFilter && (emd.getTipo() == Tipo.FLOAT || emd.getTipo() == Tipo.INTEGER)){
                esr.setTipo(emd.getTipo());
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr,emd,emd.getTipo());
                }else{
                    RESULT = new Suma(esr,emd, emd.getTipo());
                };*/
                    RESULT = new Suma(esr,emd, emd.getTipo());

            }
            else{
                throw new Exception("No se puede sumar entre una variable de tipo " + Tipo.toString(esr.getTipo()) + " y una variable de tipo " + Tipo.toString(emd.getTipo()));
            }
       :}
       |
       expresion_sr :esr OPERADOR_RESTA expresion_md: emd{:
            produccionesRecorridas.add("expresion_sr -> expresion_sr OPERADOR_RESTA expresion_md");
            if(esr.getTipo() == Tipo.INTEGER && emd.getTipo() == Tipo.INTEGER){
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr,emd,Tipo.INTEGER);
                }else{
                    RESULT = new Resta(esr,emd,Tipo.INTEGER);
                };*/
                    RESULT = new Resta(esr,emd,Tipo.INTEGER);

            }
            else if(esr.getTipo() == Tipo.FLOAT && emd.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(emd);
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr,flotante,Tipo.FLOAT);
                }else{
                    RESULT = new Resta(esr,flotante,Tipo.FLOAT);
                };*/
                    RESULT = new Resta(esr,flotante,Tipo.FLOAT);

            }
            else if(esr.getTipo() == Tipo.INTEGER && emd.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr);
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(flotante,emd,Tipo.FLOAT);
                }else{
                    RESULT = new Resta(flotante,emd,Tipo.FLOAT);
                };*/
                    RESULT = new Resta(flotante,emd,Tipo.FLOAT);

            }
            else if(esr.getTipo() == Tipo.FLOAT && emd.getTipo() == Tipo.FLOAT){
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr,emd,Tipo.FLOAT);
                }else{
                    RESULT = new Resta(esr,emd, Tipo.FLOAT);
                };*/
                    RESULT = new Resta(esr,emd, Tipo.FLOAT);

            }
            else if(isGuionBajoFilter && (emd.getTipo() == Tipo.FLOAT || emd.getTipo() == Tipo.INTEGER)){
                esr.setTipo(emd.getTipo());
                /*if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr,emd,emd.getTipo());
                }else{
                    RESULT = new Resta(esr,emd, emd.getTipo());
                };*/
                    RESULT = new Resta(esr,emd, emd.getTipo());

            }
            else{
                throw new Exception("No se puede restar entre una variable de tipo " + Tipo.toString(esr.getTipo()) + " y una variable de tipo " + Tipo.toString(emd.getTipo()));
            }
       :}
       |
       expresion_md :emd{:
            produccionesRecorridas.add("expresion_sr -> expresion_md");
            RESULT = emd;
:};


expresion_md ::= expresion_md :emd OPERADOR_MULTI menos_unario:mu{:
        produccionesRecorridas.add("expresion_md -> expresion_md OPERADOR_MULTI menos_unario");
        if(emd.getTipo() == Tipo.INTEGER && mu.getTipo() == Tipo.INTEGER){
            /*if (isExpresionFilter){
                RESULT =new ExpresionFilter(emd,mu,Tipo.INTEGER);
            }else{
                RESULT = new Multiplicacion(emd,mu, Tipo.INTEGER);
            };*/
                RESULT = new Multiplicacion(emd,mu, Tipo.INTEGER);

        }
        else if(emd.getTipo() == Tipo.FLOAT && mu.getTipo() == Tipo.INTEGER){
            EnteroAFlotante flotante = new EnteroAFlotante(mu);
            /*if (isExpresionFilter){
                RESULT =new ExpresionFilter(emd,flotante,Tipo.FLOAT);
            }else{
                RESULT = new Multiplicacion(emd,flotante, Tipo.FLOAT);
            };*/
                RESULT = new Multiplicacion(emd,flotante, Tipo.FLOAT);

        }
        else if(emd.getTipo() == Tipo.INTEGER && mu.getTipo() == Tipo.FLOAT){
            EnteroAFlotante flotante = new EnteroAFlotante(emd);
            /*if (isExpresionFilter){
                RESULT =new ExpresionFilter(flotante,mu,Tipo.FLOAT);
            }else{
                RESULT = new Multiplicacion(flotante,mu,Tipo.FLOAT);
            };*/
                RESULT = new Multiplicacion(flotante,mu,Tipo.FLOAT);

        }
        else if(emd.getTipo() == Tipo.FLOAT && mu.getTipo() == Tipo.FLOAT){
            /*if (isExpresionFilter){
                RESULT =new ExpresionFilter(emd,mu,Tipo.FLOAT);
            }else{
                RESULT = new Multiplicacion(emd,mu,Tipo.FLOAT);
            };*/
                RESULT = new Multiplicacion(emd,mu,Tipo.FLOAT);

        }
        else if(isGuionBajoFilter && (mu.getTipo() == Tipo.FLOAT || mu.getTipo() == Tipo.INTEGER)){
            emd.setTipo(mu.getTipo());
            /*if (isExpresionFilter){
                RESULT =new ExpresionFilter(emd,mu,mu.getTipo());
            }else{
                RESULT = new Multiplicacion(emd,mu,mu.getTipo());
            };*/
                RESULT = new Multiplicacion(emd,mu,mu.getTipo());

        }
        else{
            throw new Exception("No se puede multiplicar entre una variable de tipo " + Tipo.toString(emd.getTipo()) + " y una variable de tipo " + Tipo.toString(mu.getTipo()));
        }
    :}
    |
    expresion_md :emd OPERADOR_DIV menos_unario:mu{:
        produccionesRecorridas.add("expresion_md -> expresion_md OPERADOR_DIV menos_unario");
        if(emd.getTipo() == Tipo.INTEGER && mu.getTipo() == Tipo.INTEGER){
            /*if (isExpresionFilter){
                RESULT =new ExpresionFilter(emd,mu,Tipo.INTEGER);
            }else{
                RESULT = new Division(emd,mu, Tipo.INTEGER);
            };*/
            RESULT = new Division(emd,mu, Tipo.INTEGER);

        }
        else if(emd.getTipo() == Tipo.FLOAT && mu.getTipo() == Tipo.INTEGER){
            EnteroAFlotante flotante = new EnteroAFlotante(mu);
            /*if (isExpresionFilter){
                RESULT =new ExpresionFilter(emd,flotante,Tipo.FLOAT);
            }else{
                RESULT = new Division(emd,flotante, Tipo.FLOAT);
            };*/
            RESULT = new Division(emd,flotante, Tipo.FLOAT);

        }
        else if(emd.getTipo() == Tipo.INTEGER && mu.getTipo() == Tipo.FLOAT){
            EnteroAFlotante flotante = new EnteroAFlotante(emd);
            /*if (isExpresionFilter){
                RESULT =new ExpresionFilter(flotante,mu,Tipo.FLOAT);
            }else{
                RESULT = new Division(flotante,mu, Tipo.FLOAT);
            };*/
            RESULT = new Division(flotante,mu, Tipo.FLOAT);

        }
        else if(emd.getTipo() == Tipo.FLOAT && mu.getTipo() == Tipo.FLOAT){
            /*if (isExpresionFilter){
                RESULT =new ExpresionFilter(emd,mu,Tipo.FLOAT);
            }else{
                RESULT = new Division(emd,mu, Tipo.FLOAT);
            };*/
            RESULT = new Division(emd,mu, Tipo.FLOAT);

        }
        else if(isGuionBajoFilter && (mu.getTipo() == Tipo.FLOAT || mu.getTipo() == Tipo.INTEGER)){
            emd.setTipo(mu.getTipo());
            /*if(isExpresionFilter){
                RESULT =new ExpresionFilter(emd,mu,mu.getTipo());
            }else{
                RESULT = new Division(emd,mu, mu.getTipo());
            };*/
            RESULT = new Division(emd,mu, mu.getTipo());

        }
        else{
            throw new Exception("No se puede dividir entre una variable de tipo " + Tipo.toString(emd.getTipo()) + " y una variable de tipo " + Tipo.toString(mu.getTipo()));
        }
    :}
    |
    menos_unario:mu{:
        produccionesRecorridas.add("expresion_md -> menos_unario");
        RESULT = mu;
    :};

menos_unario ::= OPERADOR_RESTA menos_unario:mu{:
        produccionesRecorridas.add("menos_unario -> OPERADOR_RESTA menos_unario");
        if(mu.getTipo() == Tipo.INTEGER){
            /*if (isExpresionFilter){
                RESULT = new ExpresionFilter(new NegacionAritmetica(mu,"sub",Tipo.INTEGER),mu,Tipo.INTEGER);
            }else{
                RESULT = new NegacionAritmetica(mu,"sub",Tipo.INTEGER);
            };*/
        RESULT = new NegacionAritmetica(mu,"sub",Tipo.INTEGER);
        }else if(mu.getTipo() == Tipo.FLOAT){
            /*if (isExpresionFilter){
                RESULT = new ExpresionFilter(new NegacionAritmetica(mu,"fsub",Tipo.FLOAT),mu,Tipo.FLOAT);
            }else{
                RESULT =  new NegacionAritmetica(mu,"fsub",Tipo.FLOAT);
            };*/
            RESULT =  new NegacionAritmetica(mu,"fsub",Tipo.FLOAT);

        }
        else{
            throw new Exception("No se puede negar una variable de tipo " + Tipo.toString(mu.getTipo()));
        }
    :}
    |
    factor:f {:
        produccionesRecorridas.add("menos_unario -> factor");
        RESULT = f;
:};


factor ::= constante: c{:
        produccionesRecorridas.add("factor -> constante");
        isConstante = true;
        RESULT = c;
       :}
       |
    filter:f{:
        produccionesRecorridas.add("factor -> filter");
        RESULT = f;
    :}
    |
    PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA{:
        produccionesRecorridas.add("factor -> PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA");
        RESULT = eo;
    :}
    |
    GUION_BAJO: gb{:
        produccionesRecorridas.add("factor -> GUION_BAJO");
        isGuionBajoFilter = true;
        RESULT = new GuionBajo("_");
    :}    
    |
    input: in{:
        produccionesRecorridas.add("factor ->  input");
        RESULT = in;
:};


constante::= CONST_BOOL:bl{:
        produccionesRecorridas.add("constante -> CONST_BOOL");
        constantesFilter.add(new Booleano(Boolean.parseBoolean(bl)));
        RESULT = new Booleano(Boolean.parseBoolean(bl));
    :}
    |
    CONST_INT:il{:
        produccionesRecorridas.add("constante -> CONST_INT");
        constantesFilter.add(new Entero(Integer.parseInt(il)));
        RESULT = new Entero(Integer.parseInt(il));
    :}
    |
    CONST_FLOAT:fl{:
        produccionesRecorridas.add("constante -> CONST_FLOAT");
        
        constantesFilter.add(new Flotante(Float.parseFloat(fl)));
        
        RESULT = new Flotante(Float.parseFloat(fl));
    :}
    |
    STRING_LITERAL:fl{:
        produccionesRecorridas.add("constante -> STRING_LITERAL");
        
        constantesFilter.add(new StringLiteral(fl));
        
        RESULT = new StringLiteral(fl);
    :}
    |
    VAR:id{:
        produccionesRecorridas.add("constante -> VAR");
        if(!ht.containsKey(id)){
            throw new VarNotDeclaredTSException("La variable " + id + " no está declarada previamente.");
        }
        Tipo tipoId = ht.get(id);
        RESULT = new Identificador(id, tipoId);
 :};


filter::= FILTER PARENTESIS_ABRE {: isExpresionFilter = true;:} expresion_or:e_o COMA CORCHETE_ABRE lista_var:l_v CORCHETE_CIERRA PARENTESIS_CIERRA {:
    SentenciaIf sentenciaIf;
    ArrayList<SentenciaElif> sentenciasELIF = new ArrayList<SentenciaElif>();
    ArrayList<Sentencia> sentenciasDentroIF = new ArrayList<>();
    ArrayList<Sentencia> sentenciasDentroELSE = new ArrayList<>();

    Filter filter;
    
    produccionesRecorridas.add("filter -> FILTER PARENTESIS_ABRE expresion_or COMA CORCHETE_ABRE lista_var CORCHETE_CIERRA PARENTESIS_CIERRA");
    
    Tipo tipoIdAsignacion = ht.get(idAsignacionFilter);
    Tipo tipoResultadosFilter = obtenerTipoReturnFilter(l_v);

    Tipo tipoExpresion = e_o.getTipo();
    String nombreOperacion = e_o.getEtiqueta();

    System.out.println("nombreOperacion: " + nombreOperacion);
    System.out.println("tipoExpresion: " + Tipo.toString(tipoExpresion));

    Identificador resultadoFilter;
    Identificador variable;
    
    Expresion expresionIF = null;

    for(int j =0; j < l_v.size(); j++){
        String auxVar = l_v.get(j);
        if(!ht.containsKey(auxVar)){
            throw new VarNotDeclaredTSException("La variable " + auxVar + " no esta declarada previamente\n");
        }else{
            Tipo tipoAuxVar = ht.get(auxVar);
            if(isAsignacionFilter==true){
                if(!validarTiposVariablesConTipoAsignacionId(auxVar)){
                    throw new VarTypeNotCompatibleWithVarListTypes("El Tipo " + Tipo.toString(tipoAuxVar) +  " de la variable "+ auxVar +" no coincide con el Tipo " + tipoIdAsignacion + " de la Asignacion con la variable " + idAsignacionFilter + " \n");
                }
            }else{
                /*if(!validarTiposVariablesConExpresion(auxVar,e_o)){
                    throw new VarTypeNotEqualWithVarListTypes("El Tipo " + Tipo.toString(tipoAuxVar) +  " de la variable "+ auxVar +" no coincide con el Tipo " + e_o.getTipo() + " de la Expresion \n");
                }*/
            }
                 

            autoincrementalAuxFilter = autoincrementalAuxFilter +1;

            
            if(isAsignacionFilter==true){
                resultadoFilter = new Identificador("_aux" + autoincrementalAuxFilter.toString(), tipoResultadosFilter);
                variable = new Identificador(auxVar, tipoResultadosFilter);
            }else{
                if (e_o.getTipo() == Tipo.INTEGER || e_o.getTipo() == Tipo.FLOAT){
                    resultadoFilter = new Identificador("_aux" + autoincrementalAuxFilter.toString(), Tipo.FLOAT);
                    variable = new Identificador(auxVar, Tipo.FLOAT);
                }else{
                    resultadoFilter = new Identificador("_aux" + autoincrementalAuxFilter.toString(), Tipo.BOOLEAN);
                    variable = new Identificador(auxVar, Tipo.BOOLEAN);
                }
            }
            

            if(j==0){ //si es la primera variable de la lista de variables 
                    Asignacion asignacion = new Asignacion(resultadoFilter, variable); //agrego la asignacion dentro del IF sentencia dentro del IF
                    sentenciasDentroIF.add(asignacion);
                    expresionIF = e_o.reemplazarExpresionIzquierda(auxVar);
            }
            if(j>0 && l_v.size()>1){ //sentencias dentro del elif  
                Asignacion asignacion = new Asignacion(resultadoFilter, variable); //agrego la sentencias del elif
                ArrayList<Sentencia> sentenciasDentroELIF = new ArrayList<>();
                sentenciasDentroELIF.add(asignacion);
                sentenciasELIF.add(new SentenciaElif(sentenciasDentroELIF, e_o.reemplazarExpresionIzquierda(auxVar)));
            }
        }
    }
    
    if(isAsignacionFilter==true){
        resultadoFilter = new Identificador("_aux" + autoincrementalAuxFilter.toString(), tipoResultadosFilter);
        variable = new Identificador("_retornoFilterDefault", tipoResultadosFilter);
    }else{
        if (e_o.getTipo() == Tipo.INTEGER || e_o.getTipo() == Tipo.FLOAT){
            resultadoFilter = new Identificador("_aux" + autoincrementalAuxFilter.toString(), Tipo.FLOAT);
            variable = new Identificador("_retornoFilterDefault", Tipo.FLOAT);
        }else{
            resultadoFilter = new Identificador("_aux" + autoincrementalAuxFilter.toString(), Tipo.BOOLEAN);
            variable = new Identificador("_retornoFilterDefault", Tipo.BOOLEAN);
        }
    }

    Asignacion asignacion = new Asignacion(resultadoFilter,variable); //agrego la sentencia dentro del  ELIF
    sentenciasDentroELSE.add(asignacion); 

    
    sentenciaIf = new SentenciaIf(sentenciasDentroIF,expresionIF,sentenciasELIF, sentenciasDentroELSE);
    
    if(isAsignacionFilter==true){
        filter = new Filter(sentenciaIf, tipoResultadosFilter);
    }else{
        filter = new Filter(sentenciaIf, tipoResultadosFilter);
    }

    pilaFilter.add(filter);

    autoincrementalAuxFilter = autoincrementalAuxFilter +1;
    
    if(isAsignacionFilter==true){
        resultadoFilter = new Identificador("_aux" + autoincrementalAuxFilter.toString(), tipoResultadosFilter);
    }else{
        if (e_o.getTipo() == Tipo.INTEGER || e_o.getTipo() == Tipo.FLOAT){
            resultadoFilter = new Identificador("_aux" + autoincrementalAuxFilter.toString(), Tipo.FLOAT);
        }else{
            resultadoFilter = new Identificador("_aux" + autoincrementalAuxFilter.toString(), Tipo.BOOLEAN);
        }
    }

    isAsignacionFilter = false;
    isGuionBajoFilter = false;
    isExpresionFilter = false;

    RESULT = resultadoFilter;
:};

sentencia_display ::= DISPLAY PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA {:
    produccionesRecorridas.add("sentencia_display -> DISPLAY PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA");
    RESULT = new Display(eo);
:};

input ::= input_int:ii {:
        produccionesRecorridas.add("input -> input_int");
        RESULT = ii;
    :}
    |
    input_float:ifl {:
        produccionesRecorridas.add("input -> input_float");
        RESULT = ifl;
    :}
    |
    input_bool:ib {:
        produccionesRecorridas.add("input -> input_bool");
        RESULT = ib;
:};


input_int ::= INPUT_INT PARENTESIS_ABRE PARENTESIS_CIERRA {:
    produccionesRecorridas.add("input_int -> INPUT_INT PARENTESIS_ABRE PARENTESIS_CIERRA");
    RESULT = new Input(Tipo.INTEGER);
:};

input_float ::= INPUT_FLOAT PARENTESIS_ABRE PARENTESIS_CIERRA {:
    produccionesRecorridas.add("input_float -> INPUT_FLOAT PARENTESIS_ABRE PARENTESIS_CIERRA");
    RESULT = new Input(Tipo.FLOAT);
:};

input_bool ::= INPUT_BOOL PARENTESIS_ABRE PARENTESIS_CIERRA {:
    produccionesRecorridas.add("input_bool -> INPUT_BOOL PARENTESIS_ABRE PARENTESIS_CIERRA");
    RESULT = new Input(Tipo.BOOLEAN);
:};

sentencia_if ::= IF PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA THEN bloque_sentencias:bs END {:
        produccionesRecorridas.add("sentencia_if -> IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias END");
        RESULT = new SentenciaIf(bs,eo);
    :}
    |
    IF PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA THEN bloque_sentencias:bs1 ELSE THEN bloque_sentencias:bs2 END{:
        produccionesRecorridas.add("sentencia_if -> IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias ELSE THEN bloque_sentencias END");
        ArrayList<SentenciaElif> sentenciasElif = new ArrayList<>();
        RESULT = new SentenciaIf(bs1,eo, sentenciasElif,bs2);
    :}
    |
    IF PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA THEN bloque_sentencias:bs1 sentencia_elseif: elseif END{:
        produccionesRecorridas.add("sentencia_if -> IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias sentencia_elseif END");
        ArrayList<Sentencia> sentenciasElse = new ArrayList<>();
        RESULT = new SentenciaIf(bs1,eo,elseif, sentenciasElse);
    :}
    |
    IF PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA THEN bloque_sentencias:bs1 sentencia_elseif: elseif ELSE THEN bloque_sentencias:bs2 END{:
        produccionesRecorridas.add("sentencia_if -> IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias sentencia_elseif ELSE THEN bloque_sentencias END");
        RESULT = new SentenciaIf(bs1,eo,elseif, bs2);
:};


sentencia_elseif ::= sentencia_elseif: elseif ELIF PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA THEN bloque_sentencias:bs2{:
        produccionesRecorridas.add("sentencia_elseif -> sentencia_elseif ELIF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias");
        elseif.add(new SentenciaElif(bs2,eo));
        RESULT = elseif;
    :}
    |
    ELIF PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA THEN bloque_sentencias:bs2{:
        produccionesRecorridas.add("sentencia_elseif -> ELIF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias");
        ArrayList<SentenciaElif> listaElif = new ArrayList<>();
        listaElif.add(new SentenciaElif(bs2,eo));
        RESULT = listaElif;
:};


expresion_incremento_decremento ::= OPERADOR_SUMA:op expresion_sr: esr2{:
        produccionesRecorridas.add("expresion_incremento_decremento -> OPERADOR_SUMA expresion_sr");
        RESULT = new IncrementoDecrementoFor(esr2,op,Tipo.INTEGER);
    :}
    |
    OPERADOR_RESTA:op expresion_sr: esr2{:
        produccionesRecorridas.add("expresion_incremento_decremento -> OPERADOR_RESTA expresion_sr");
        RESULT = new IncrementoDecrementoFor(esr2,op,Tipo.INTEGER);
    :}
    | OPERADOR_SUMA:op OPERADOR_SUMA: esr2{:
        produccionesRecorridas.add("expresion_incremento_decremento -> OPERADOR_SUMA OPERADOR_SUMA");
        RESULT = new IncrementoDecrementoFor(null,op,Tipo.INTEGER);
    :}
    | OPERADOR_RESTA:op OPERADOR_RESTA: esr2{:
        produccionesRecorridas.add("expresion_incremento_decremento -> OPERADOR_RESTA OPERADOR_RESTA");
        RESULT = new IncrementoDecrementoFor(null,op,Tipo.INTEGER);
:};

sentencia_for ::= FOR PARENTESIS_ABRE VAR:id1 ASIGNACION CONST_INT  PUNTO_COMA VAR:id2 expresion_incremento_decremento:e_id PUNTO_COMA comparacion:c_f  PARENTESIS_CIERRA DO bloque_sentencias:bs END{:
        
    //Verificar que c_f contenga el mismo id que id1 y id2;
    if((id1).equals(id2) && (id1).equals(c_f.getIdVar())){

        //ht.put(id1+'VARIABLE_FOR',Tipo.INTEGER);
        if(!ht.containsKey(id1)){
            throw new VarNotDeclaredTSException("La variable " + id1 + " no está declarada previamente.");
        }
    }else{
        throw new VarForNotEqualException("La variable utlizada en el FOR debe ser la misma");
    }

    //ArrayList<Sentencia> sentencias = new ArrayList<>();
    produccionesRecorridas.add("sentencia_for -> FOR PARENTESIS_ABRE VAR ASIGNACION CONST_INT PUNTO_COMA VAR expresion_incremento_decremento PUNTO_COMA comparacion PARENTESIS_CIERRA DO bloque_sentencias END");
    Asignacion asignacion = new Asignacion(new Identificador(id1,Tipo.INTEGER),e_id);

    is_sentencia_for = false;

   // RESULT = new SentenciaFor(c_f,asignacion,e_id,sentencias);
    RESULT = new SentenciaFor(c_f,asignacion,e_id,bs);
:};
