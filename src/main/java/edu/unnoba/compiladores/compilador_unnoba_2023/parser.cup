package edu.unnoba.compiladores.compilador_unnoba_2023;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import java.io.FileReader;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.Hashtable;
import edu.unnoba.compiladores.compilador_unnoba_2023.exceptions.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast_expresiones.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast_expresiones_binarias.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast_expresiones_binarias.logicas.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast_expresiones_unarias.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.factor.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.sentencias.*;
import java.util.Iterator;


//crear un metodo de clase que genere un autoincremental
class MiParser;
action code {:
:};

parser code
{:
    public ArrayList<String> variablesString = new ArrayList<>();

    Integer autoincrementalAuxFilter = 0;

    boolean isSentenciaFor = false;

    Boolean isAsignacionFilter = false;
    Boolean isGuionBajoFilter = false;
    boolean isExpresionFilter = false;

    ArrayList<Filter> pilaFilter = new ArrayList<>();

    List<String> produccionesRecorridas = new ArrayList<>();

    ArrayList<String> pilaFor = new ArrayList<>();

    ArrayList<String> pilaVariablesInFor = new ArrayList<>();
    
    String idAsignacionFilter; 

    public List<String> getProduccionesList(){
        return this.produccionesRecorridas;
    }

    public boolean verificarOperacionConComparacion(IncrementoDecrementoFor e_id, OperacionBinaria c_f){
        boolean retorno=false; 
        if(e_id.getOperacion().equals("++")){
            if(c_f.getNombreOperacion().equals(">") || c_f.getNombreOperacion().equals(">=")) retorno = true;
        }else{
            if(c_f.getNombreOperacion().equals("<") || c_f.getNombreOperacion().equals("<=")) retorno = true;
        }
        return retorno;
    }

    public boolean validarTiposVariablesConExpresion(String var, Expresion expresion_or){
        boolean retorno=true;
        Tipo tipoAuxVar = ht.get(var);
        if(expresion_or.getTipo() != tipoAuxVar){
            if((expresion_or.getTipo() == Tipo.BOOLEAN && tipoAuxVar == Tipo.INTEGER) || (expresion_or.getTipo() == Tipo.INTEGER && tipoAuxVar ==Tipo.BOOLEAN) || (expresion_or.getTipo() == Tipo.FLOAT && tipoAuxVar ==Tipo.BOOLEAN) || (expresion_or.getTipo() == Tipo.BOOLEAN && tipoAuxVar == Tipo.FLOAT) ){
                retorno = false;
            }
        }
        
        return retorno;
    }
    
    public boolean validarTiposVariablesConTipoAsignacionId(String var){
        boolean retorno = true;
        Tipo tipoIdAsignacion = ht.get(idAsignacionFilter);
        
        Tipo tipoAuxVar = ht.get(var);
        if(tipoIdAsignacion == Tipo.BOOLEAN &&  tipoAuxVar != Tipo.BOOLEAN){
            retorno = false;
        }else if((tipoIdAsignacion == Tipo.INTEGER || tipoIdAsignacion == Tipo.FLOAT) && tipoAuxVar == Tipo.BOOLEAN){
            retorno = false;
        }else if(tipoIdAsignacion == Tipo.INTEGER && (tipoAuxVar == Tipo.BOOLEAN || tipoIdAsignacion == Tipo.FLOAT)){
            retorno = false;
        }
     
        return retorno;
    }

    public boolean validarTiposListaVariablesInFilter(ArrayList<String> l_v){
        boolean retorno = true;
        Tipo tipoVarAnterior = ht.get(l_v.get(0));
        
        for(String auxVar : l_v){
            Tipo tipoVarActual = ht.get(auxVar);
            if(tipoVarActual != tipoVarAnterior){
                if(tipoVarActual == Tipo.BOOLEAN){
                    retorno = false;
                }else if(tipoVarAnterior == Tipo.BOOLEAN){
                    retorno = false;
                }
                tipoVarAnterior = tipoVarActual; 
            }
        }
     
        return retorno;
    }

    public Tipo obtenerTipoReturnFilter(ArrayList<String> l_v){
        Tipo tipoReturn = Tipo.UNKNOWN;
        for(String auxVar : l_v){
            tipoReturn = ht.get(auxVar);
            if(tipoReturn == Tipo.FLOAT || tipoReturn == Tipo.BOOLEAN){
                break;
            }
        }
        return tipoReturn;
    }

    
   

    public String printProduccionesRecorridas(List<String> misProducciones){
        String textoConcat = "";
        textoConcat = textoConcat.concat("Pasó por las siguientes reglas:\n");
        for(String txt : misProducciones){
            textoConcat = textoConcat.concat(txt).concat("\n");
        }
        return textoConcat;
    }

    Hashtable<String, Tipo> ht = new Hashtable<String, Tipo>();

    public Hashtable<String, Tipo> getSymbolTable(){
        return this.ht;
    }

    Hashtable<String, Constante> htValor = new Hashtable<String, Constante>();

    public Hashtable<String, Constante> getValueTable(){
        return this.htValor;
    }

    public void printHt(Hashtable<String, Tipo> ht){
        ht.forEach((k, v) -> {
            System.out.println("Tabla de simbolos: " + k.toString() + " " + Tipo.toString(v));
        });
    }
    public String concatHt(Hashtable<String, Tipo> ht){
        Iterator<String> iterator = ht.keySet().iterator();
        String concatenado = "\nTabla de simbolos:\n";

        while(iterator.hasNext()) {
            String clave = iterator.next();
            Tipo tipo = ht.get(clave);
            concatenado += clave.concat(" -> ").concat(Tipo.toString(tipo)).concat("\n");
        }
        return concatenado;
    }

    private String s;

    public void syntax_error(Symbol s){
        this.s="Error en la linea "+ (s.right+1)+ " Columna "+ (s.left+1)+ ". Valor simbolo '"
        +s.value+"' . Simbolo n° "+s.sym+ " no reconocido.";
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        this.s="Error en la linea "+ (s.right+1)+ " Columna "+ (s.left+1)+ ". Valor simbolo '"
        +s.value+"' . Simbolo n° "+s.sym+ " no reconocido." ;
    }

    public String getS(){
        return this.s;
    }
:};

terminal String OPERADOR_SUMA, OPERADOR_RESTA, OPERADOR_DIV, OPERADOR_MULTI, PARENTESIS_ABRE, PARENTESIS_CIERRA,LLAVE_ABRE,LLAVE_CIERRA, OPERADOR_IGUAL,
OPERADOR_DISTINTO, OPERADOR_MAYOR, OPERADOR_MENOR, OPERADOR_MENOR_IGUAL, OPERADOR_MAYOR_IGUAL, OPERADOR_AND, OPERADOR_OR, OPERADOR_NOT,
FOR, DO, CORCHETE_ABRE, CORCHETE_CIERRA, COMA, DOS_PUNTOS, PUNTO_COMA, END, BREAK, CONTINUE, INT_TYPE, FLOAT_TYPE,STRING_LITERAL,
BOOLEAN_TYPE, FILTER, DISPLAY, DECLARE_SECTION, END_DECLARE_SECTION, PROGRAM_SECTION, END_PROGRAM_SECTION, CONST_BOOL, CONST_INT, CONST_FLOAT,
VAR, ASIGNACION, INPUT_INT, INPUT_FLOAT, INPUT_BOOL, GUION_BAJO, IF, ELSE, ELIF, THEN;

nonterminal Programa programa;
nonterminal ArrayList<ArrayList<Declaracion>> declaraciones;
nonterminal ArrayList<Declaracion> declaracion;
nonterminal ArrayList<Sentencia> bloque_programa;
nonterminal ArrayList<ArrayList<Declaracion>> bloque_declaraciones;
nonterminal ArrayList<Sentencia> bloque_sentencias;
nonterminal Sentencia sentencia;
nonterminal Sentencia sentencia_for;
nonterminal Sentencia sentencia_if;
nonterminal Sentencia sentencia_asignacion;
nonterminal Sentencia sentencia_display;
nonterminal Expresion expresion_or;
nonterminal Expresion input;
nonterminal Expresion expresion_and;
nonterminal Expresion expresion_not;
nonterminal Expresion comparacion;
nonterminal Expresion expresion_sr;
nonterminal Expresion expresion_md;
nonterminal Expresion menos_unario;
nonterminal Expresion factor;
nonterminal Constante constante;
nonterminal Expresion filter;
nonterminal Expresion input_int;
nonterminal Expresion input_float;
nonterminal Expresion input_bool;
nonterminal IncrementoDecrementoFor expresion_incremento_decremento; 
nonterminal ArrayList<SentenciaElif> sentencia_elseif;
nonterminal ArrayList<String> lista_var;

start with programa;

programa ::= bloque_declaraciones:bd bloque_programa: bp{:
        produccionesRecorridas.add("programa ->");
        RESULT = new Programa(bp,bd, ht, variablesString);
    :}
    |
   bloque_programa: bp{:
        produccionesRecorridas.add("programa ->");
        RESULT = new Programa(bp, ht, variablesString);
:};


bloque_declaraciones ::= DECLARE_SECTION declaraciones:d END_DECLARE_SECTION{:
        produccionesRecorridas.add("bloque_declaraciones -> DECLARE_SECTION declaraciones END_DECLARE_SECTION");
        RESULT  = d;
:};


declaraciones ::= declaracion:dec declaraciones:decs{:
        produccionesRecorridas.add("declaraciones -> declaracion declaraciones");
        decs.add(dec);
        RESULT = decs;
   :}
   |
   declaracion:dec{:
        produccionesRecorridas.add("declaraciones -> declaracion");
        ArrayList<ArrayList<Declaracion>> declaracionesRegla = new ArrayList<ArrayList<Declaracion>>();
        declaracionesRegla.add(dec);
        RESULT = declaracionesRegla;
        
:};

lista_var::= lista_var:l_v COMA VAR:id{:
        produccionesRecorridas.add("lista_var -> lista_var COMA VAR");
        l_v.add(id);
        RESULT = l_v;
    :}
    |
    VAR:id{:
        produccionesRecorridas.add("lista_var -> VAR");
        ArrayList<String> ident = new ArrayList<String>();
        ident.add(id);
        RESULT = ident;
:};

declaracion ::= INT_TYPE:tipo DOS_PUNTOS lista_var:l_v PUNTO_COMA{:
        produccionesRecorridas.add("declaracion -> INT_TYPE DOS_PUNTOS lista_var PUNTO_COMA");
        ArrayList<Declaracion> declaraciones = new ArrayList<>();
        for(String i : l_v){
            if(ht.containsKey(i)){
                throw new VarAlreadyExistTSException("La variable "+i+" ya esta definida\n");
            }
            else{
                ht.put(i,Tipo.INTEGER);
                declaraciones.add(new Declaracion(Tipo.INTEGER, new Identificador(i, Tipo.INTEGER)));
            }
        }
        RESULT = declaraciones;
    :}
    |
    FLOAT_TYPE DOS_PUNTOS lista_var:l_v  PUNTO_COMA{:
        produccionesRecorridas.add("declaracion -> FLOAT_TYPE DOS_PUNTOS lista_var PUNTO_COMA");
        ArrayList<Declaracion> declaraciones = new ArrayList<>();
        for(String i : l_v){
            if(ht.containsKey(i)){
                throw new VarAlreadyExistTSException("La variable "+i+" ya esta definida\n");
            }
            else{
                ht.put(i,Tipo.FLOAT);
                declaraciones.add(new Declaracion(Tipo.FLOAT, new Identificador(i, Tipo.FLOAT)));
            }
        }
        RESULT = declaraciones;
    :}
    |
    BOOLEAN_TYPE DOS_PUNTOS lista_var:l_v PUNTO_COMA{:
        produccionesRecorridas.add("declaracion -> BOOLEAN_TYPE DOS_PUNTOS lista_var PUNTO_COMA");
        ArrayList<Declaracion> declaraciones = new ArrayList<>();
        for(String i : l_v){
            if(ht.containsKey(i)){
                throw new VarAlreadyExistTSException("La variable "+i+" ya esta definida\n");
            
            }
            else{
                ht.put(i,Tipo.BOOLEAN);
                declaraciones.add(new Declaracion(Tipo.BOOLEAN, new Identificador(i, Tipo.BOOLEAN)));
                
            }
        }
        RESULT = declaraciones;
:};


bloque_programa ::= PROGRAM_SECTION bloque_sentencias:bs END_PROGRAM_SECTION{:
    produccionesRecorridas.add("bloque_programa -> PROGRAM_SECTION bloque_sentencias END_PROGRAM_SECTION");
    RESULT = bs;
:};


bloque_sentencias ::= bloque_sentencias:bs sentencia:s {:
            produccionesRecorridas.add("bloque_sentencias -> bloque_sentencias:bs sentencia");  
            for(Filter filter : pilaFilter){
                System.out.println("bloque_sentencias filter");
                bs.add((Sentencia)filter);
            }
            pilaFilter.clear();
            bs.add(s);
            RESULT = bs;
       :}
       |
       sentencia:s {:
            produccionesRecorridas.add("bloque_sentencias -> sentencia");
            ArrayList<Sentencia> sentencias = new ArrayList<>();
            for(Filter filter : pilaFilter){
                System.out.println("bloque_sentencias filter");
                sentencias.add((Sentencia)filter);
            }
            pilaFilter.clear();
            sentencias.add(s);
            RESULT  = sentencias;
:};


sentencia ::= sentencia_for: sf{:
            produccionesRecorridas.add("sentencia -> sentencia_for");
            RESULT = sf;
       :}
       |
       sentencia_if: sif{:
            produccionesRecorridas.add("sentencia -> sentencia_if");
            RESULT = sif;
       :}
       |
       sentencia_asignacion: sa{:
            produccionesRecorridas.add("sentencia -> sentencia_asignacion");
            RESULT = sa;
       :}
       |
       sentencia_display: sd{:
            produccionesRecorridas.add("sentencia -> sentencia_display");
            RESULT = sd;
        :}
        |
        BREAK: b{:
            if(!isSentenciaFor){
                throw new Exception("El BREAK no se encuentra dentro del FOR");
            }
            produccionesRecorridas.add("sentencia -> BREAK");
            RESULT = new Break(); 
        :}
        |
        CONTINUE: c{:
            if(!isSentenciaFor){
                throw new Exception("El CONTINUE no se encuentra dentro del FOR");
            }
            produccionesRecorridas.add("sentencia -> CONTINUE");
            RESULT = new Continue();
:};


sentencia_asignacion ::= VAR:id ASIGNACION {:

    isAsignacionFilter= true;
    idAsignacionFilter = id;
    :} expresion_or: eo {:
        produccionesRecorridas.add("sentencia_asignacion -> VAR ASIGNACION expresion_or");
        
        if(!ht.containsKey(id)){
            throw new VarNotDeclaredTSException("La variable "+(String) id+" no está declarada previamente.");
        }
        
        if(pilaVariablesInFor.contains(id)){
            throw new VarForException("No es posible editar la variable " + id + " ya que, es utilizada en un FOR");
        }
        
        
        Tipo tipoId = ht.get(id);
            
        Asignacion asig =new Asignacion(new Identificador(id, tipoId),eo);
        
        Tipo tipoExpresion = eo.getTipo();
        
        if (tipoExpresion == tipoId || tipoId == Tipo.FLOAT && tipoExpresion == Tipo.INTEGER){
            if (tipoId == Tipo.FLOAT && tipoExpresion == Tipo.INTEGER) {
                asig = new Asignacion(new Identificador(id, tipoId),new EnteroAFlotante(eo));
            }else {
                asig = new Asignacion(new Identificador(id, tipoId),eo);
            }
            
        }else{
            throw new Exception("No se puede realizar la asignacion de " + id + " de tipo " +  Tipo.toString(tipoId)  + " con " + eo.getNombre() + "  de tipo " + Tipo.toString(tipoExpresion));
        }
        RESULT = asig;
:};


expresion_or ::= expresion_or: eo OPERADOR_OR expresion_and :ea{:
        produccionesRecorridas.add("expresion_or -> expresion_or OPERADOR_OR expresion_and");

        if(eo.getTipo() == Tipo.BOOLEAN && ea.getTipo() == Tipo.BOOLEAN){
            RESULT =new Or(eo,ea);
        }
        else{
            throw new Exception("No se puede realizar la expresion OR entre una variable del tipo " + Tipo.toString(eo.getTipo()) + " y una variable de tipo " + Tipo.toString(ea.getTipo()));
        }
       :}
       |
       expresion_and :ea{:
            produccionesRecorridas.add("expresion_or -> expresion_and");
            RESULT = ea; 
:};


expresion_and ::= expresion_and: ea OPERADOR_AND expresion_not :en{:
        produccionesRecorridas.add("expresion_and -> expresion_and OPERADOR_AND expresion_not");
        if(ea.getTipo() == Tipo.BOOLEAN && en.getTipo() == Tipo.BOOLEAN){
            RESULT =new And(ea,en);
        }
        else{
            throw new Exception("No se puede realizar la expresion AND entre una variable del tipo " + Tipo.toString(ea.getTipo()) + " y una variable de tipo " + Tipo.toString(en.getTipo()));
        }
    :}
    |
    expresion_not :en{:
        produccionesRecorridas.add("expresion_and -> expresion_not");
        RESULT = en;
:};


expresion_not ::= OPERADOR_NOT expresion_not :en{:
        produccionesRecorridas.add("expresion_not -> OPERADOR_NOT expresion_not");
        if(en.getTipo() == Tipo.BOOLEAN){
            RESULT =new NegacionLogica(en);
        }
        else{
            throw new Exception("No se puede realizar la expresion NOT con una variable del tipo " +  Tipo.toString(en.getTipo()));
        }        
       :}
       |
       comparacion:c{:
        produccionesRecorridas.add("expresion_not -> comparacion");
        RESULT = c;
:};



comparacion ::= expresion_sr :esr1 OPERADOR_MAYOR expresion_sr: esr2{:
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_MAYOR expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                RESULT = new Mayor(esr1,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                RESULT = new Mayor(esr1,flotante);
            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                RESULT = new Mayor(flotante,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                RESULT = new Mayor(esr1,esr2);
            }
            else if(isGuionBajoFilter && (esr2.getTipo() == Tipo.FLOAT || esr2.getTipo() == Tipo.INTEGER)){
                esr1.setTipo(esr2.getTipo());
                RESULT = new Mayor(esr1,esr2);
            }
            else{
                throw new Exception("La variable de tipo " + Tipo.toString(esr1.getTipo()) + " no puede compararse con el operador > con una variable del tipo " + Tipo.toString(esr2.getTipo()));
            }
       :}
       |
       expresion_sr :esr1 OPERADOR_MAYOR_IGUAL expresion_sr: esr2{:
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_MAYOR_IGUAL expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){          
                RESULT = new MayorIgual(esr1,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                RESULT = new MayorIgual(esr1,flotante);
            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                RESULT = new MayorIgual(flotante,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                RESULT = new MayorIgual(esr1,esr2);

            }
            else if(isGuionBajoFilter && (esr2.getTipo() == Tipo.FLOAT || esr2.getTipo() == Tipo.INTEGER)){
                esr1.setTipo(esr2.getTipo());
                RESULT = new MayorIgual(esr1,esr2);
            }
            else{
                throw new Exception("La variable de tipo " + Tipo.toString(esr1.getTipo()) + " no puede compararse con el operador >= con una variable del tipo " + Tipo.toString(esr2.getTipo()));
            }
       :}
       |
       expresion_sr :esr1 OPERADOR_MENOR expresion_sr: esr2{:
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_MENOR expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                RESULT = new Menor(esr1,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                RESULT = new Menor(esr1,flotante);
            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                RESULT = new Menor(flotante,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                RESULT = new Menor(esr1,esr2);
            }
            else if(isGuionBajoFilter && (esr2.getTipo() == Tipo.FLOAT || esr2.getTipo() == Tipo.INTEGER)){
                esr1.setTipo(esr2.getTipo());
                RESULT = new Menor(esr1,esr2);
            }
            else{
                throw new Exception("La variable de tipo " + Tipo.toString(esr1.getTipo()) + " no puede compararse con el operador < con una variable del tipo " + Tipo.toString(esr2.getTipo()));
            }
       :}
       |
       expresion_sr :esr1 OPERADOR_MENOR_IGUAL expresion_sr: esr2{:
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_MENOR_IGUAL expresion_s");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                RESULT = new MenorIgual(esr1,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                RESULT = new MenorIgual(esr1,flotante);
            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                RESULT = new MenorIgual(flotante,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                RESULT = new MenorIgual(esr1,esr2);

            }
            else if(isGuionBajoFilter && (esr2.getTipo() == Tipo.FLOAT || esr2.getTipo() == Tipo.INTEGER)){
                esr1.setTipo(esr2.getTipo());
                RESULT = new MenorIgual(esr1,esr2);                
            }
            else{
                throw new Exception("La variable de tipo " + Tipo.toString(esr1.getTipo()) + " no puede compararse con el operador < con una variable del tipo " + Tipo.toString(esr2.getTipo()));
            }
       :}
       |
       expresion_sr :esr1 OPERADOR_IGUAL expresion_sr: esr2{:
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_IGUAL expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                RESULT = new Igualdad(esr1,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                RESULT = new Igualdad(esr1,flotante);
            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                RESULT = new Igualdad(flotante,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                RESULT = new Igualdad(esr1,esr2);
            }
            else if(esr1.getTipo() == Tipo.BOOLEAN && esr2.getTipo() == Tipo.BOOLEAN){
                RESULT = new Igualdad(esr1,esr2);
            }
            else if(isGuionBajoFilter && (esr2.getTipo() == Tipo.FLOAT || esr2.getTipo() == Tipo.INTEGER || esr2.getTipo() == Tipo.BOOLEAN)){
                esr1.setTipo(esr2.getTipo());
                RESULT = new Igualdad(esr1,esr2);
            }
            else{
                throw new Exception("La variable de tipo " + Tipo.toString(esr1.getTipo()) + " no puede compararse con el operador == con una variable del tipo " + Tipo.toString(esr2.getTipo()));
            }
       :}
       |
       expresion_sr :esr1 OPERADOR_DISTINTO expresion_sr: esr2{:
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_DISTINTO expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                RESULT = new Desigualdad(esr1,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                RESULT = new Desigualdad(esr1,flotante);
            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                RESULT = new Desigualdad(flotante,esr2);
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                RESULT = new Desigualdad(esr1,esr2);
            }
            else if(esr1.getTipo() == Tipo.BOOLEAN && esr2.getTipo() == Tipo.BOOLEAN){
                RESULT = new Desigualdad(esr1,esr2);
            }
            else if(isGuionBajoFilter && (esr2.getTipo() == Tipo.FLOAT || esr2.getTipo() == Tipo.INTEGER || esr2.getTipo() == Tipo.BOOLEAN)){
                esr1.setTipo(esr2.getTipo());
                RESULT = new Desigualdad(esr1,esr2);
            }
            else{
                throw new Exception("La variable de tipo " + Tipo.toString(esr1.getTipo()) + " no puede compararse con el operador != con una variable del tipo " + Tipo.toString(esr2.getTipo()));
            }
       :}
       |
       expresion_sr :esr{:
            produccionesRecorridas.add("comparacion -> expresion_sr");
            RESULT = esr;
:};


expresion_sr ::= expresion_sr :esr OPERADOR_SUMA expresion_md: emd{:
            produccionesRecorridas.add("expresion_sr ->expresion_sr OPERADOR_SUMA expresion_md");
             if(esr.getTipo() == Tipo.INTEGER && emd.getTipo() == Tipo.INTEGER){
                RESULT = new Suma(esr,emd , Tipo.INTEGER);
            }
            else if(esr.getTipo() == Tipo.FLOAT && emd.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(emd);
                RESULT = new Suma(esr,flotante , Tipo.FLOAT);

            }
            else if(esr.getTipo() == Tipo.INTEGER && emd.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr);
                RESULT = new Suma(flotante,emd, Tipo.FLOAT);
            }
            else if(esr.getTipo() == Tipo.FLOAT && emd.getTipo() == Tipo.FLOAT){
                RESULT = new Suma(esr,emd, Tipo.FLOAT);

            }
            else if(isGuionBajoFilter && (emd.getTipo() == Tipo.FLOAT || emd.getTipo() == Tipo.INTEGER)){
                esr.setTipo(emd.getTipo());
                RESULT = new Suma(esr,emd, emd.getTipo());
            }
            else{
                throw new Exception("No se puede sumar entre una variable de tipo " + Tipo.toString(esr.getTipo()) + " y una variable de tipo " + Tipo.toString(emd.getTipo()));
            }
       :}
       |
       expresion_sr :esr OPERADOR_RESTA expresion_md: emd{:
            produccionesRecorridas.add("expresion_sr -> expresion_sr OPERADOR_RESTA expresion_md");
            if(esr.getTipo() == Tipo.INTEGER && emd.getTipo() == Tipo.INTEGER){
                RESULT = new Resta(esr,emd,Tipo.INTEGER);

            }
            else if(esr.getTipo() == Tipo.FLOAT && emd.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(emd);
                RESULT = new Resta(esr,flotante,Tipo.FLOAT);

            }
            else if(esr.getTipo() == Tipo.INTEGER && emd.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr);
                RESULT = new Resta(flotante,emd,Tipo.FLOAT);

            }
            else if(esr.getTipo() == Tipo.FLOAT && emd.getTipo() == Tipo.FLOAT){
                RESULT = new Resta(esr,emd, Tipo.FLOAT);

            }
            else if(isGuionBajoFilter && (emd.getTipo() == Tipo.FLOAT || emd.getTipo() == Tipo.INTEGER)){
                esr.setTipo(emd.getTipo());
                RESULT = new Resta(esr,emd, emd.getTipo());

            }
            else{
                throw new Exception("No se puede restar entre una variable de tipo " + Tipo.toString(esr.getTipo()) + " y una variable de tipo " + Tipo.toString(emd.getTipo()));
            }
       :}
       |
       expresion_md :emd{:
            produccionesRecorridas.add("expresion_sr -> expresion_md");
            RESULT = emd;
:};


expresion_md ::= expresion_md :emd OPERADOR_MULTI menos_unario:mu{:
        produccionesRecorridas.add("expresion_md -> expresion_md OPERADOR_MULTI menos_unario");
        if(emd.getTipo() == Tipo.INTEGER && mu.getTipo() == Tipo.INTEGER){
            RESULT = new Multiplicacion(emd,mu, Tipo.INTEGER);
        }
        else if(emd.getTipo() == Tipo.FLOAT && mu.getTipo() == Tipo.INTEGER){
            EnteroAFlotante flotante = new EnteroAFlotante(mu);
            RESULT = new Multiplicacion(emd,flotante, Tipo.FLOAT);

        }
        else if(emd.getTipo() == Tipo.INTEGER && mu.getTipo() == Tipo.FLOAT){
            EnteroAFlotante flotante = new EnteroAFlotante(emd);
            RESULT = new Multiplicacion(flotante,mu,Tipo.FLOAT);

        }
        else if(emd.getTipo() == Tipo.FLOAT && mu.getTipo() == Tipo.FLOAT){
            RESULT = new Multiplicacion(emd,mu,Tipo.FLOAT);

        }
        else if(isGuionBajoFilter && (mu.getTipo() == Tipo.FLOAT || mu.getTipo() == Tipo.INTEGER)){
            emd.setTipo(mu.getTipo());
            RESULT = new Multiplicacion(emd,mu,mu.getTipo());

        }
        else{
            throw new Exception("No se puede multiplicar entre una variable de tipo " + Tipo.toString(emd.getTipo()) + " y una variable de tipo " + Tipo.toString(mu.getTipo()));
        }
    :}
    |
    expresion_md :emd OPERADOR_DIV menos_unario:mu{:
        produccionesRecorridas.add("expresion_md -> expresion_md OPERADOR_DIV menos_unario");
        if(emd.getTipo() == Tipo.INTEGER && mu.getTipo() == Tipo.INTEGER){
            RESULT = new Division(emd,mu, Tipo.INTEGER);

        }
        else if(emd.getTipo() == Tipo.FLOAT && mu.getTipo() == Tipo.INTEGER){
            EnteroAFlotante flotante = new EnteroAFlotante(mu);
            RESULT = new Division(emd,flotante, Tipo.FLOAT);

        }
        else if(emd.getTipo() == Tipo.INTEGER && mu.getTipo() == Tipo.FLOAT){
            EnteroAFlotante flotante = new EnteroAFlotante(emd);
            RESULT = new Division(flotante,mu, Tipo.FLOAT);

        }
        else if(emd.getTipo() == Tipo.FLOAT && mu.getTipo() == Tipo.FLOAT){
            RESULT = new Division(emd,mu, Tipo.FLOAT);

        }
        else if(isGuionBajoFilter && (mu.getTipo() == Tipo.FLOAT || mu.getTipo() == Tipo.INTEGER)){
            emd.setTipo(mu.getTipo());
            RESULT = new Division(emd,mu, mu.getTipo());

        }
        else{
            throw new Exception("No se puede dividir entre una variable de tipo " + Tipo.toString(emd.getTipo()) + " y una variable de tipo " + Tipo.toString(mu.getTipo()));
        }
    :}
    |
    menos_unario:mu{:
        produccionesRecorridas.add("expresion_md -> menos_unario");
        RESULT = mu;
    :};

menos_unario ::= OPERADOR_RESTA menos_unario:mu{:
        produccionesRecorridas.add("menos_unario -> OPERADOR_RESTA menos_unario");
        if(mu.getTipo() == Tipo.INTEGER){
            RESULT = new NegacionAritmetica(mu,"sub",Tipo.INTEGER);
        }else if(mu.getTipo() == Tipo.FLOAT){
            RESULT =  new NegacionAritmetica(mu,"fsub",Tipo.FLOAT);
        }
        else{
            throw new Exception("No se puede negar una variable de tipo " + Tipo.toString(mu.getTipo()));
        }
    :}
    |
    factor:f {:
        produccionesRecorridas.add("menos_unario -> factor");
        RESULT = f;
:};


factor ::= constante: c{:
        produccionesRecorridas.add("factor -> constante");
        RESULT = c;
       :}
       |
    filter:f{:
        produccionesRecorridas.add("factor -> filter");
        RESULT = f;
    :}
    |
    PARENTESIS_ABRE         {:
        isExpresionFilter = true;
    :}
     expresion_or:eo PARENTESIS_CIERRA{:
        produccionesRecorridas.add("factor -> PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA");
        isExpresionFilter = false;
        RESULT = eo;
    :}
    |
    GUION_BAJO: gb{:
        produccionesRecorridas.add("factor -> GUION_BAJO");
        isGuionBajoFilter = true;
        RESULT = new GuionBajo("GuionBajo", Tipo.UNKNOWN, "_", Tipo.UNKNOWN);
    :}    
    |
    input: in{:
        produccionesRecorridas.add("factor ->  input");
        RESULT = in;
:};


constante::= CONST_BOOL:bl{:
        produccionesRecorridas.add("constante -> CONST_BOOL");
        RESULT = new Booleano(Boolean.parseBoolean(bl));
    :}
    |
    CONST_INT:il{:
        produccionesRecorridas.add("constante -> CONST_INT");
        RESULT = new Entero(Integer.parseInt(il));
    :}
    |
    CONST_FLOAT:fl{:
        produccionesRecorridas.add("constante -> CONST_FLOAT");        
        RESULT = new Flotante(Float.parseFloat(fl));
    :}
    |
    STRING_LITERAL:fl{:
        produccionesRecorridas.add("constante -> STRING_LITERAL");        
        RESULT = new StringLiteral(fl);
    :}
    |
    VAR:id{:
        produccionesRecorridas.add("constante -> VAR");
        if(!ht.containsKey(id)){
            throw new VarNotDeclaredTSException("La variable " + id + " no está declarada previamente.");
        }
        Tipo tipoId = ht.get(id);
        RESULT = new Identificador(id, tipoId);
 :};


filter::= FILTER PARENTESIS_ABRE expresion_or:e_o COMA CORCHETE_ABRE lista_var:l_v CORCHETE_CIERRA PARENTESIS_CIERRA {:
    produccionesRecorridas.add("filter -> FILTER PARENTESIS_ABRE expresion_or COMA CORCHETE_ABRE lista_var CORCHETE_CIERRA PARENTESIS_CIERRA");


    SentenciaIf sentenciaIf;
    ArrayList<SentenciaElif> sentenciasELIF = new ArrayList<SentenciaElif>();
    ArrayList<Sentencia> sentenciasDentroIF = new ArrayList<>();
    ArrayList<Sentencia> sentenciasDentroELSE = new ArrayList<>();

    Filter filter;
    
    Tipo tipoIdAsignacion = Tipo.UNKNOWN;
    if(isAsignacionFilter==true){
       tipoIdAsignacion = ht.get(idAsignacionFilter);
    }

    Tipo tipoResultadoFilter = obtenerTipoReturnFilter(l_v);

    Identificador resultadoFilter;
    Identificador variable;
    
    Expresion expresionIF = null;
    Expresion expresionNueva = null;

    Tipo tipoExpresionDerecha = e_o.getTipoExpresionDerecha();

    for(int j =0; j < l_v.size(); j++){
        String auxVar = l_v.get(j);
        if(!ht.containsKey(auxVar)){
            throw new VarNotDeclaredTSException("La variable " + auxVar + " no esta declarada previamente\n");
        }else{
            Tipo tipoAuxVar = ht.get(auxVar);
            if (l_v.size() > 1){
                if (!validarTiposListaVariablesInFilter(l_v)){
                    throw new VarTypeNotCompatibleWithVarListTypes("El Tipo de las variables debe ser una combinacion de FLOAT/INTEGER o solo BOOLEAN\n");
                }
            }
            if (tipoExpresionDerecha != tipoAuxVar){
                if(tipoExpresionDerecha == Tipo.BOOLEAN){
                    throw new VarTypeNotEqualWithVarListTypes("El Tipo " + Tipo.toString(tipoAuxVar) +  " de la variable "+ auxVar +" no coincide con el Tipo " + Tipo.toString(tipoExpresionDerecha) + " de la Expresion \n");
                }else if(tipoAuxVar == Tipo.BOOLEAN){
                    throw new VarTypeNotEqualWithVarListTypes("El Tipo " + Tipo.toString(tipoAuxVar) +  " de la variable "+ auxVar +" no coincide con el Tipo " + Tipo.toString(tipoExpresionDerecha) + " de la Expresion \n");
                }else {
                    expresionNueva = e_o.reemplazarExpresionIzquierda(auxVar, tipoAuxVar);
                    if (tipoExpresionDerecha == Tipo.INTEGER && tipoAuxVar==Tipo.FLOAT){ // tengo que castear el entero de la expresion DERECHA a flotante
                       expresionNueva = e_o.reemplazarExpresionDerecha(auxVar, tipoAuxVar);
                    }
                }

     
            }else{

                expresionNueva = e_o.reemplazarExpresionIzquierda(auxVar, tipoAuxVar);
            }

            //agrego a la tabla de simbolos la variables que reemplazan _ ('GUION BAJO') utilizadas en la comparacion del filter
            /*if(!ht.containsKey("_auxFilter" + auxVar)){
                ht.put("_auxFilter" + auxVar,tipoAuxVar);
            }*/

            

            if(isAsignacionFilter==true){
                if(!validarTiposVariablesConTipoAsignacionId(auxVar)){
                    throw new VarTypeNotCompatibleWithVarListTypes("El Tipo " + Tipo.toString(tipoAuxVar) +  " de la variable "+ auxVar +" no coincide con el Tipo " + Tipo.toString(tipoIdAsignacion) + " de la Asignacion con la variable " + idAsignacionFilter + " \n");
                }
            }
            
            resultadoFilter = new Identificador("_aux" + autoincrementalAuxFilter.toString(), tipoResultadoFilter);
            variable = new Identificador(auxVar, tipoAuxVar);
            
            Asignacion asignacion;
            if (tipoResultadoFilter == Tipo.FLOAT && tipoAuxVar == Tipo.INTEGER){
                asignacion = new Asignacion(resultadoFilter, new EnteroAFlotante(variable));
            }else if(tipoResultadoFilter == Tipo.INTEGER && tipoAuxVar == Tipo.FLOAT){
                throw new Exception("No se puede realizar la asignacion de _aux" + autoincrementalAuxFilter.toString() + " de tipo " +  Tipo.toString(tipoResultadoFilter)  + " con " + auxVar + "  de tipo " + Tipo.toString(tipoAuxVar));
            }else{
                asignacion = new Asignacion(resultadoFilter, variable);
            }

            if(j==0){ //si es la primera variable de la lista de variables
                    sentenciasDentroIF.add(asignacion);
                    expresionIF =expresionNueva;
            }
            if(j>0 && l_v.size()>1){ //sentencias dentro del elif  
                ArrayList<Sentencia> sentenciasDentroELIF = new ArrayList<>();
                sentenciasDentroELIF.add(asignacion);
                sentenciasELIF.add(new SentenciaElif(sentenciasDentroELIF, expresionNueva));

            }
        }
    }
    
    //agrego la variable del filter a la tabla de simbolos
    ht.put("_aux" + autoincrementalAuxFilter.toString(),tipoResultadoFilter);

    //agrego la variable del filter default a la tabla de simbolos
    if(!ht.containsKey("_retornoFilterDefault")){
        ht.put("_retornoFilterDefault",tipoResultadoFilter);
    }

    resultadoFilter = new Identificador("_aux" + autoincrementalAuxFilter.toString(), tipoResultadoFilter);
    variable = new Identificador("_retornoFilterDefault", tipoResultadoFilter);


    Asignacion asignacion = new Asignacion(resultadoFilter,variable); //agrego la sentencia dentro del  ELIF
    sentenciasDentroELSE.add(asignacion);

    sentenciaIf = new SentenciaIf(sentenciasDentroIF,expresionIF,sentenciasELIF, sentenciasDentroELSE);
    

    filter = new Filter(sentenciaIf, tipoResultadoFilter, isExpresionFilter);
    

    pilaFilter.add(filter);
    

    resultadoFilter = new Identificador("_aux" + autoincrementalAuxFilter.toString(), tipoResultadoFilter);

    
    autoincrementalAuxFilter = autoincrementalAuxFilter +1;
    isAsignacionFilter = false;
    isGuionBajoFilter = false;
    RESULT = resultadoFilter;
:} 
|
FILTER PARENTESIS_ABRE expresion_or:e_o COMA CORCHETE_ABRE CORCHETE_CIERRA PARENTESIS_CIERRA {:
    Tipo tipoResultadoFilter = Tipo.UNKNOWN;
    Identificador resultadoFilter = new Identificador("_aux" + autoincrementalAuxFilter.toString(), tipoResultadoFilter);
    
    if (tipoResultadoFilter ==Tipo.UNKNOWN ){
        throw new ListVarEmptyException("La lista de variables no puede estar vacia.");
    }

    RESULT = resultadoFilter;
:};

sentencia_display ::= DISPLAY PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA {:
    produccionesRecorridas.add("sentencia_display -> DISPLAY PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA");
    if (eo.getNombre().equals("String")){
        variablesString.add(eo.generarCodigo());
        RESULT = new Display(eo, ((StringLiteral)eo).getValor().length());
    }else{
        RESULT = new Display(eo);
    }

:};

input ::= input_int:ii {:
        produccionesRecorridas.add("input -> input_int");
        RESULT = ii;
    :}
    |
    input_float:ifl {:
        produccionesRecorridas.add("input -> input_float");
        RESULT = ifl;
    :}
    |
    input_bool:ib {:
        produccionesRecorridas.add("input -> input_bool");
        RESULT = ib;
:};


input_int ::= INPUT_INT:i_int PARENTESIS_ABRE PARENTESIS_CIERRA {:
    produccionesRecorridas.add("input_int -> INPUT_INT PARENTESIS_ABRE PARENTESIS_CIERRA");
    RESULT = new Input(Tipo.INTEGER, i_int);
:};

input_float ::= INPUT_FLOAT:i_float PARENTESIS_ABRE PARENTESIS_CIERRA {:
    produccionesRecorridas.add("input_float -> INPUT_FLOAT PARENTESIS_ABRE PARENTESIS_CIERRA"); 
    RESULT = new Input(Tipo.FLOAT, i_float);
:};

input_bool ::= INPUT_BOOL:i_bool PARENTESIS_ABRE PARENTESIS_CIERRA {:
    produccionesRecorridas.add("input_bool -> INPUT_BOOL PARENTESIS_ABRE PARENTESIS_CIERRA"); 
    RESULT = new Input(Tipo.BOOLEAN, i_bool);
:};

sentencia_if ::= IF PARENTESIS_ABRE 
    expresion_or:eo PARENTESIS_CIERRA THEN bloque_sentencias:bs END {:
        produccionesRecorridas.add("sentencia_if -> IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias END");
        RESULT = new SentenciaIf(bs,eo);
    :}
    |
    IF PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA THEN bloque_sentencias:bs1 END ELSE bloque_sentencias:bs2 END{:
        produccionesRecorridas.add("sentencia_if -> IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias ELSE bloque_sentencias END");
        ArrayList<SentenciaElif> sentenciasElif = new ArrayList<>();
        RESULT = new SentenciaIf(bs1,eo, sentenciasElif,bs2);
    :}
    |
    IF PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA THEN bloque_sentencias:bs1 END sentencia_elseif: elseif{:
        produccionesRecorridas.add("sentencia_if -> IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias sentencia_elseif END");
        ArrayList<Sentencia> sentenciasElse = new ArrayList<>();
        RESULT = new SentenciaIf(bs1,eo,elseif, sentenciasElse);
    :}
    |
    IF PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA THEN bloque_sentencias:bs1 END sentencia_elseif: elseif ELSE bloque_sentencias:bs2 END{:
        produccionesRecorridas.add("sentencia_if -> IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias sentencia_elseif ELSE bloque_sentencias END");
        RESULT = new SentenciaIf(bs1,eo,elseif, bs2);
:};


sentencia_elseif ::= sentencia_elseif: elseif ELIF PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA THEN bloque_sentencias:bs2 END{:
        produccionesRecorridas.add("sentencia_elseif -> sentencia_elseif ELIF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias");
        elseif.add(new SentenciaElif(bs2,eo));
        RESULT = elseif;
    :}
    |
    ELIF PARENTESIS_ABRE expresion_or:eo PARENTESIS_CIERRA THEN bloque_sentencias:bs2 END{:
        produccionesRecorridas.add("sentencia_elseif -> ELIF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias");
        ArrayList<SentenciaElif> listaElif = new ArrayList<>();
        listaElif.add(new SentenciaElif(bs2,eo));
        RESULT = listaElif;
:};


expresion_incremento_decremento ::= VAR:var OPERADOR_SUMA:op OPERADOR_SUMA: op2{:
        produccionesRecorridas.add("expresion_incremento_decremento -> OPERADOR_SUMA OPERADOR_SUMA");
        if(!ht.containsKey(var)){
            throw new VarNotDeclaredTSException("La variable " + var + " no está declarada previamente.");
        }else{
            Tipo tipoVar = ht.get(var);
            if(tipoVar != Tipo.INTEGER){
                throw new Exception("La variable " + var + " es del tipo: " + tipoVar + ". En la sentencia FOR solo se acepta INTEGER");
            }
        }
        Identificador identificador = new Identificador(var,Tipo.INTEGER);
        RESULT = new IncrementoDecrementoFor(identificador,op + op2,Tipo.INTEGER);
    :}
    | VAR:var OPERADOR_RESTA:op OPERADOR_RESTA: op2{:
        produccionesRecorridas.add("expresion_incremento_decremento -> OPERADOR_RESTA OPERADOR_RESTA");
        if(!ht.containsKey(var)){
            throw new VarNotDeclaredTSException("La variable " + var + " no está declarada previamente.");
        }else{
            Tipo tipoVar = ht.get(var);
            if(tipoVar != Tipo.INTEGER){
                throw new Exception("La variable " + var + " es del tipo: " + tipoVar + ". En la sentencia FOR solo se acepta INTEGER");
            }
        }
        Identificador identificador = new Identificador(var,Tipo.INTEGER);
        RESULT = new IncrementoDecrementoFor(identificador,op + op2,Tipo.INTEGER);
:};
sentencia_for ::= FOR PARENTESIS_ABRE VAR:id1 ASIGNACION CONST_INT:intAux  PUNTO_COMA expresion_incremento_decremento:e_id PUNTO_COMA comparacion:c_f  PARENTESIS_CIERRA DO {:
    pilaFor.add("for"); 
    isSentenciaFor = true;        
    if (pilaVariablesInFor.contains(id1)) {
        throw new VarForException("No es posible volver a utlizar la variable " + id1 + " ya que, es utilizada en otro FOR");
    } else {
        pilaVariablesInFor.add(id1);
    }

    :} bloque_sentencias:bs END{:
    produccionesRecorridas.add("sentencia_for -> FOR PARENTESIS_ABRE VAR ASIGNACION CONST_INT PUNTO_COMA VAR expresion_incremento_decremento PUNTO_COMA comparacion PARENTESIS_CIERRA DO bloque_sentencias END");
    //Verificar que c_f contenga el mismo id que id1 y id2;
    String id2 = ((Identificador)e_id.getExpresion()).getNombre();
    if((id1).equals(id2)){
        if (!c_f.ComparacionFor(id1)){       
            pilaVariablesInFor.remove(pilaVariablesInFor.size()-1);
            pilaFor.remove(pilaFor.size()-1);
            if(pilaFor.isEmpty()){
                isSentenciaFor = false;
            }
            throw new ComparacionForException("El For no admite este tipo de comparacion"); //ademas compara la tercer variable del for 
        }
        if(!ht.containsKey(id1)){
            pilaVariablesInFor.remove(pilaVariablesInFor.size()-1);
            pilaFor.remove(pilaFor.size()-1);
            if(pilaFor.isEmpty()){
                isSentenciaFor = false;
            }
            throw new VarNotDeclaredTSException("La variable " + id1 + " no está declarada previamente.");
        }
        if(verificarOperacionConComparacion(e_id, (OperacionBinaria)c_f)) throw new Exception("La Comparacion no es compatible con el tipo de operacion.");



    }else{
        pilaVariablesInFor.remove(pilaVariablesInFor.size()-1);
        pilaFor.remove(pilaFor.size()-1);
        if(pilaFor.isEmpty()){
            isSentenciaFor = false;
        }
        throw new VarForNotEqualException("La variable utlizada en el FOR debe ser la misma");
    }

    
    Entero entero = new Entero(Integer.parseInt(intAux));
    Asignacion asignacion = new Asignacion(new Identificador(id1,Tipo.INTEGER),entero);
    
    pilaVariablesInFor.remove(pilaVariablesInFor.size()-1);
    pilaFor.remove(pilaFor.size()-1);

    if(pilaFor.isEmpty()){
        isSentenciaFor = false;
    }
    
    
    RESULT = new SentenciaFor(c_f,asignacion,e_id,bs);
:};
