
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20150326 (SVN rev 63)
//----------------------------------------------------

package edu.unnoba.compiladores.compilador_unnoba_2023;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import java.io.FileReader;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.Hashtable;
import edu.unnoba.compiladores.compilador_unnoba_2023.exceptions.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast_expresiones.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast_expresiones_binarias.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast_expresiones_binarias.logicas.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.ast_expresiones_unarias.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.factor.*;
import edu.unnoba.compiladores.compilador_unnoba_2023.sentencias.*;
import java.util.Iterator;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20150326 (SVN rev 63) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class MiParser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return MiParserSym.class;
}

  /** Default constructor. */
  @Deprecated
  public MiParser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public MiParser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public MiParser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\111\000\002\002\004\000\002\002\004\000\002\002" +
    "\003\000\002\006\005\000\002\003\004\000\002\003\003" +
    "\000\002\035\005\000\002\035\003\000\002\004\006\000" +
    "\002\004\006\000\002\004\006\000\002\005\005\000\002" +
    "\007\004\000\002\007\003\000\002\010\003\000\002\010" +
    "\003\000\002\010\003\000\002\010\003\000\002\010\003" +
    "\000\002\010\003\000\002\036\002\000\002\013\006\000" +
    "\002\015\005\000\002\015\003\000\002\017\005\000\002" +
    "\017\003\000\002\020\004\000\002\020\003\000\002\021" +
    "\005\000\002\021\005\000\002\021\005\000\002\021\005" +
    "\000\002\021\005\000\002\021\005\000\002\021\003\000" +
    "\002\022\005\000\002\022\005\000\002\022\003\000\002" +
    "\023\005\000\002\023\005\000\002\023\003\000\002\024" +
    "\004\000\002\024\003\000\002\025\003\000\002\025\003" +
    "\000\002\025\005\000\002\025\003\000\002\025\003\000" +
    "\002\026\003\000\002\026\003\000\002\026\003\000\002" +
    "\026\003\000\002\026\003\000\002\037\002\000\002\027" +
    "\013\000\002\014\006\000\002\016\003\000\002\016\003" +
    "\000\002\016\003\000\002\030\005\000\002\031\005\000" +
    "\002\032\005\000\002\012\011\000\002\012\014\000\002" +
    "\012\012\000\002\012\015\000\002\034\011\000\002\034" +
    "\010\000\002\033\004\000\002\033\004\000\002\033\004" +
    "\000\002\033\004\000\002\011\020" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\242\000\006\045\010\047\006\001\002\000\004\047" +
    "\006\001\002\000\004\002\243\001\002\000\016\025\034" +
    "\035\047\036\045\044\036\054\041\062\042\001\002\000" +
    "\004\002\uffff\001\002\000\010\037\014\040\013\042\015" +
    "\001\002\000\004\046\033\001\002\000\012\037\014\040" +
    "\013\042\015\046\ufffc\001\002\000\004\032\027\001\002" +
    "\000\004\032\024\001\002\000\004\032\016\001\002\000" +
    "\004\054\017\001\002\000\010\030\ufffa\031\ufffa\033\ufffa" +
    "\001\002\000\006\031\021\033\022\001\002\000\004\054" +
    "\023\001\002\000\012\037\ufff7\040\ufff7\042\ufff7\046\ufff7" +
    "\001\002\000\010\030\ufffb\031\ufffb\033\ufffb\001\002\000" +
    "\004\054\017\001\002\000\006\031\021\033\026\001\002" +
    "\000\012\037\ufff9\040\ufff9\042\ufff9\046\ufff9\001\002\000" +
    "\004\054\017\001\002\000\006\031\021\033\031\001\002" +
    "\000\012\037\ufff8\040\ufff8\042\ufff8\046\ufff8\001\002\000" +
    "\004\046\ufffd\001\002\000\004\047\ufffe\001\002\000\004" +
    "\010\220\001\002\000\026\025\ufff4\034\ufff4\035\ufff4\036" +
    "\ufff4\044\ufff4\050\ufff4\054\ufff4\062\ufff4\063\ufff4\064\ufff4" +
    "\001\002\000\004\010\215\001\002\000\026\025\ufff3\034" +
    "\ufff3\035\ufff3\036\ufff3\044\ufff3\050\ufff3\054\ufff3\062\ufff3" +
    "\063\ufff3\064\ufff3\001\002\000\026\025\ufff1\034\ufff1\035" +
    "\ufff1\036\ufff1\044\ufff1\050\ufff1\054\ufff1\062\ufff1\063\ufff1" +
    "\064\ufff1\001\002\000\004\055\212\001\002\000\004\010" +
    "\052\001\002\000\026\025\ufff0\034\ufff0\035\ufff0\036\ufff0" +
    "\044\ufff0\050\ufff0\054\ufff0\062\ufff0\063\ufff0\064\ufff0\001" +
    "\002\000\020\025\034\035\047\036\045\044\036\050\051" +
    "\054\041\062\042\001\002\000\026\025\uffee\034\uffee\035" +
    "\uffee\036\uffee\044\uffee\050\uffee\054\uffee\062\uffee\063\uffee" +
    "\064\uffee\001\002\000\026\025\ufff2\034\ufff2\035\ufff2\036" +
    "\ufff2\044\ufff2\050\ufff2\054\ufff2\062\ufff2\063\ufff2\064\ufff2" +
    "\001\002\000\026\025\uffef\034\uffef\035\uffef\036\uffef\044" +
    "\uffef\050\uffef\054\uffef\062\uffef\063\uffef\064\uffef\001\002" +
    "\000\026\025\ufff5\034\ufff5\035\ufff5\036\ufff5\044\ufff5\050" +
    "\ufff5\054\ufff5\062\ufff5\063\ufff5\064\ufff5\001\002\000\004" +
    "\002\ufff6\001\002\000\034\005\064\010\060\024\055\041" +
    "\067\043\072\051\074\052\102\053\101\054\104\056\062" +
    "\057\103\060\105\061\057\001\002\000\064\004\uffc8\005" +
    "\uffc8\006\uffc8\007\uffc8\011\uffc8\014\uffc8\015\uffc8\016\uffc8" +
    "\017\uffc8\020\uffc8\021\uffc8\022\uffc8\023\uffc8\025\uffc8\031" +
    "\uffc8\033\uffc8\034\uffc8\035\uffc8\036\uffc8\044\uffc8\050\uffc8" +
    "\054\uffc8\062\uffc8\063\uffc8\064\uffc8\001\002\000\064\004" +
    "\uffc7\005\uffc7\006\uffc7\007\uffc7\011\uffc7\014\uffc7\015\uffc7" +
    "\016\uffc7\017\uffc7\020\uffc7\021\uffc7\022\uffc7\023\uffc7\025" +
    "\uffc7\031\uffc7\033\uffc7\034\uffc7\035\uffc7\036\uffc7\044\uffc7" +
    "\050\uffc7\054\uffc7\062\uffc7\063\uffc7\064\uffc7\001\002\000" +
    "\034\005\064\010\060\024\055\041\067\043\072\051\074" +
    "\052\102\053\101\054\104\056\062\057\103\060\105\061" +
    "\057\001\002\000\006\011\157\023\122\001\002\000\064" +
    "\004\uffd3\005\uffd3\006\uffd3\007\uffd3\011\uffd3\014\uffd3\015" +
    "\uffd3\016\uffd3\017\uffd3\020\uffd3\021\uffd3\022\uffd3\023\uffd3" +
    "\025\uffd3\031\uffd3\033\uffd3\034\uffd3\035\uffd3\036\uffd3\044" +
    "\uffd3\050\uffd3\054\uffd3\062\uffd3\063\uffd3\064\uffd3\001\002" +
    "\000\034\005\064\010\060\024\055\041\067\043\072\051" +
    "\074\052\102\053\101\054\104\056\062\057\103\060\105" +
    "\061\057\001\002\000\064\004\uffd6\005\uffd6\006\uffd6\007" +
    "\uffd6\011\uffd6\014\uffd6\015\uffd6\016\uffd6\017\uffd6\020\uffd6" +
    "\021\uffd6\022\uffd6\023\uffd6\025\uffd6\031\uffd6\033\uffd6\034" +
    "\uffd6\035\uffd6\036\uffd6\044\uffd6\050\uffd6\054\uffd6\062\uffd6" +
    "\063\uffd6\064\uffd6\001\002\000\004\010\153\001\002\000" +
    "\064\004\uffc9\005\uffc9\006\uffc9\007\uffc9\011\uffc9\014\uffc9" +
    "\015\uffc9\016\uffc9\017\uffc9\020\uffc9\021\uffc9\022\uffc9\023" +
    "\uffc9\025\uffc9\031\uffc9\033\uffc9\034\uffc9\035\uffc9\036\uffc9" +
    "\044\uffc9\050\uffc9\054\uffc9\062\uffc9\063\uffc9\064\uffc9\001" +
    "\002\000\032\005\064\010\060\041\067\043\072\051\074" +
    "\052\102\053\101\054\104\056\062\057\103\060\105\061" +
    "\057\001\002\000\036\011\uffea\022\124\023\uffea\025\uffea" +
    "\031\uffea\034\uffea\035\uffea\036\uffea\044\uffea\050\uffea\054" +
    "\uffea\062\uffea\063\uffea\064\uffea\001\002\000\064\004\uffd5" +
    "\005\uffd5\006\uffd5\007\uffd5\011\uffd5\014\uffd5\015\uffd5\016" +
    "\uffd5\017\uffd5\020\uffd5\021\uffd5\022\uffd5\023\uffd5\025\uffd5" +
    "\031\uffd5\033\uffd5\034\uffd5\035\uffd5\036\uffd5\044\uffd5\050" +
    "\uffd5\054\uffd5\062\uffd5\063\uffd5\064\uffd5\001\002\000\064" +
    "\004\uffce\005\uffce\006\uffce\007\uffce\011\uffce\014\uffce\015" +
    "\uffce\016\uffce\017\uffce\020\uffce\021\uffce\022\uffce\023\uffce" +
    "\025\uffce\031\uffce\033\uffce\034\uffce\035\uffce\036\uffce\044" +
    "\uffce\050\uffce\054\uffce\062\uffce\063\uffce\064\uffce\001\002" +
    "\000\056\004\135\005\141\011\uffdf\014\133\015\140\016" +
    "\137\017\136\020\134\021\132\022\uffdf\023\uffdf\025\uffdf" +
    "\031\uffdf\034\uffdf\035\uffdf\036\uffdf\044\uffdf\050\uffdf\054" +
    "\uffdf\062\uffdf\063\uffdf\064\uffdf\001\002\000\064\004\uffd2" +
    "\005\uffd2\006\uffd2\007\uffd2\011\uffd2\014\uffd2\015\uffd2\016" +
    "\uffd2\017\uffd2\020\uffd2\021\uffd2\022\uffd2\023\uffd2\025\uffd2" +
    "\031\uffd2\033\uffd2\034\uffd2\035\uffd2\036\uffd2\044\uffd2\050" +
    "\uffd2\054\uffd2\062\uffd2\063\uffd2\064\uffd2\001\002\000\004" +
    "\010\116\001\002\000\064\004\uffd9\005\uffd9\006\uffd9\007" +
    "\uffd9\011\uffd9\014\uffd9\015\uffd9\016\uffd9\017\uffd9\020\uffd9" +
    "\021\uffd9\022\uffd9\023\uffd9\025\uffd9\031\uffd9\033\uffd9\034" +
    "\uffd9\035\uffd9\036\uffd9\044\uffd9\050\uffd9\054\uffd9\062\uffd9" +
    "\063\uffd9\064\uffd9\001\002\000\064\004\uffd1\005\uffd1\006" +
    "\uffd1\007\uffd1\011\uffd1\014\uffd1\015\uffd1\016\uffd1\017\uffd1" +
    "\020\uffd1\021\uffd1\022\uffd1\023\uffd1\025\uffd1\031\uffd1\033" +
    "\uffd1\034\uffd1\035\uffd1\036\uffd1\044\uffd1\050\uffd1\054\uffd1" +
    "\062\uffd1\063\uffd1\064\uffd1\001\002\000\064\004\uffd7\005" +
    "\uffd7\006\uffd7\007\uffd7\011\uffd7\014\uffd7\015\uffd7\016\uffd7" +
    "\017\uffd7\020\uffd7\021\uffd7\022\uffd7\023\uffd7\025\uffd7\031" +
    "\uffd7\033\uffd7\034\uffd7\035\uffd7\036\uffd7\044\uffd7\050\uffd7" +
    "\054\uffd7\062\uffd7\063\uffd7\064\uffd7\001\002\000\036\011" +
    "\uffe8\022\uffe8\023\uffe8\025\uffe8\031\uffe8\034\uffe8\035\uffe8" +
    "\036\uffe8\044\uffe8\050\uffe8\054\uffe8\062\uffe8\063\uffe8\064" +
    "\uffe8\001\002\000\064\004\uffdc\005\uffdc\006\112\007\113" +
    "\011\uffdc\014\uffdc\015\uffdc\016\uffdc\017\uffdc\020\uffdc\021" +
    "\uffdc\022\uffdc\023\uffdc\025\uffdc\031\uffdc\033\uffdc\034\uffdc" +
    "\035\uffdc\036\uffdc\044\uffdc\050\uffdc\054\uffdc\062\uffdc\063" +
    "\uffdc\064\uffdc\001\002\000\036\011\uffe6\022\uffe6\023\uffe6" +
    "\025\uffe6\031\uffe6\034\uffe6\035\uffe6\036\uffe6\044\uffe6\050" +
    "\uffe6\054\uffe6\062\uffe6\063\uffe6\064\uffe6\001\002\000\064" +
    "\004\uffcf\005\uffcf\006\uffcf\007\uffcf\011\uffcf\014\uffcf\015" +
    "\uffcf\016\uffcf\017\uffcf\020\uffcf\021\uffcf\022\uffcf\023\uffcf" +
    "\025\uffcf\031\uffcf\033\uffcf\034\uffcf\035\uffcf\036\uffcf\044" +
    "\uffcf\050\uffcf\054\uffcf\062\uffcf\063\uffcf\064\uffcf\001\002" +
    "\000\064\004\uffd0\005\uffd0\006\uffd0\007\uffd0\011\uffd0\014" +
    "\uffd0\015\uffd0\016\uffd0\017\uffd0\020\uffd0\021\uffd0\022\uffd0" +
    "\023\uffd0\025\uffd0\031\uffd0\033\uffd0\034\uffd0\035\uffd0\036" +
    "\uffd0\044\uffd0\050\uffd0\054\uffd0\062\uffd0\063\uffd0\064\uffd0" +
    "\001\002\000\004\010\110\001\002\000\064\004\uffcd\005" +
    "\uffcd\006\uffcd\007\uffcd\011\uffcd\014\uffcd\015\uffcd\016\uffcd" +
    "\017\uffcd\020\uffcd\021\uffcd\022\uffcd\023\uffcd\025\uffcd\031" +
    "\uffcd\033\uffcd\034\uffcd\035\uffcd\036\uffcd\044\uffcd\050\uffcd" +
    "\054\uffcd\062\uffcd\063\uffcd\064\uffcd\001\002\000\004\010" +
    "\106\001\002\000\004\011\107\001\002\000\064\004\uffc4" +
    "\005\uffc4\006\uffc4\007\uffc4\011\uffc4\014\uffc4\015\uffc4\016" +
    "\uffc4\017\uffc4\020\uffc4\021\uffc4\022\uffc4\023\uffc4\025\uffc4" +
    "\031\uffc4\033\uffc4\034\uffc4\035\uffc4\036\uffc4\044\uffc4\050" +
    "\uffc4\054\uffc4\062\uffc4\063\uffc4\064\uffc4\001\002\000\004" +
    "\011\111\001\002\000\064\004\uffc5\005\uffc5\006\uffc5\007" +
    "\uffc5\011\uffc5\014\uffc5\015\uffc5\016\uffc5\017\uffc5\020\uffc5" +
    "\021\uffc5\022\uffc5\023\uffc5\025\uffc5\031\uffc5\033\uffc5\034" +
    "\uffc5\035\uffc5\036\uffc5\044\uffc5\050\uffc5\054\uffc5\062\uffc5" +
    "\063\uffc5\064\uffc5\001\002\000\032\005\064\010\060\041" +
    "\067\043\072\051\074\052\102\053\101\054\104\056\062" +
    "\057\103\060\105\061\057\001\002\000\032\005\064\010" +
    "\060\041\067\043\072\051\074\052\102\053\101\054\104" +
    "\056\062\057\103\060\105\061\057\001\002\000\064\004" +
    "\uffdb\005\uffdb\006\uffdb\007\uffdb\011\uffdb\014\uffdb\015\uffdb" +
    "\016\uffdb\017\uffdb\020\uffdb\021\uffdb\022\uffdb\023\uffdb\025" +
    "\uffdb\031\uffdb\033\uffdb\034\uffdb\035\uffdb\036\uffdb\044\uffdb" +
    "\050\uffdb\054\uffdb\062\uffdb\063\uffdb\064\uffdb\001\002\000" +
    "\064\004\uffda\005\uffda\006\uffda\007\uffda\011\uffda\014\uffda" +
    "\015\uffda\016\uffda\017\uffda\020\uffda\021\uffda\022\uffda\023" +
    "\uffda\025\uffda\031\uffda\033\uffda\034\uffda\035\uffda\036\uffda" +
    "\044\uffda\050\uffda\054\uffda\062\uffda\063\uffda\064\uffda\001" +
    "\002\000\034\005\uffcc\010\uffcc\024\uffcc\041\uffcc\043\uffcc" +
    "\051\uffcc\052\uffcc\053\uffcc\054\uffcc\056\uffcc\057\uffcc\060" +
    "\uffcc\061\uffcc\001\002\000\034\005\064\010\060\024\055" +
    "\041\067\043\072\051\074\052\102\053\101\054\104\056" +
    "\062\057\103\060\105\061\057\001\002\000\006\023\122" +
    "\031\121\001\002\000\004\027\126\001\002\000\034\005" +
    "\064\010\060\024\055\041\067\043\072\051\074\052\102" +
    "\053\101\054\104\056\062\057\103\060\105\061\057\001" +
    "\002\000\036\011\uffeb\022\124\023\uffeb\025\uffeb\031\uffeb" +
    "\034\uffeb\035\uffeb\036\uffeb\044\uffeb\050\uffeb\054\uffeb\062" +
    "\uffeb\063\uffeb\064\uffeb\001\002\000\034\005\064\010\060" +
    "\024\055\041\067\043\072\051\074\052\102\053\101\054" +
    "\104\056\062\057\103\060\105\061\057\001\002\000\036" +
    "\011\uffe9\022\uffe9\023\uffe9\025\uffe9\031\uffe9\034\uffe9\035" +
    "\uffe9\036\uffe9\044\uffe9\050\uffe9\054\uffe9\062\uffe9\063\uffe9" +
    "\064\uffe9\001\002\000\004\054\017\001\002\000\006\030" +
    "\130\031\021\001\002\000\004\011\131\001\002\000\064" +
    "\004\uffcb\005\uffcb\006\uffcb\007\uffcb\011\uffcb\014\uffcb\015" +
    "\uffcb\016\uffcb\017\uffcb\020\uffcb\021\uffcb\022\uffcb\023\uffcb" +
    "\025\uffcb\031\uffcb\033\uffcb\034\uffcb\035\uffcb\036\uffcb\044" +
    "\uffcb\050\uffcb\054\uffcb\062\uffcb\063\uffcb\064\uffcb\001\002" +
    "\000\032\005\064\010\060\041\067\043\072\051\074\052" +
    "\102\053\101\054\104\056\062\057\103\060\105\061\057" +
    "\001\002\000\032\005\064\010\060\041\067\043\072\051" +
    "\074\052\102\053\101\054\104\056\062\057\103\060\105" +
    "\061\057\001\002\000\032\005\064\010\060\041\067\043" +
    "\072\051\074\052\102\053\101\054\104\056\062\057\103" +
    "\060\105\061\057\001\002\000\032\005\064\010\060\041" +
    "\067\043\072\051\074\052\102\053\101\054\104\056\062" +
    "\057\103\060\105\061\057\001\002\000\032\005\064\010" +
    "\060\041\067\043\072\051\074\052\102\053\101\054\104" +
    "\056\062\057\103\060\105\061\057\001\002\000\032\005" +
    "\064\010\060\041\067\043\072\051\074\052\102\053\101" +
    "\054\104\056\062\057\103\060\105\061\057\001\002\000" +
    "\032\005\064\010\060\041\067\043\072\051\074\052\102" +
    "\053\101\054\104\056\062\057\103\060\105\061\057\001" +
    "\002\000\032\005\064\010\060\041\067\043\072\051\074" +
    "\052\102\053\101\054\104\056\062\057\103\060\105\061" +
    "\057\001\002\000\064\004\uffdd\005\uffdd\006\112\007\113" +
    "\011\uffdd\014\uffdd\015\uffdd\016\uffdd\017\uffdd\020\uffdd\021" +
    "\uffdd\022\uffdd\023\uffdd\025\uffdd\031\uffdd\033\uffdd\034\uffdd" +
    "\035\uffdd\036\uffdd\044\uffdd\050\uffdd\054\uffdd\062\uffdd\063" +
    "\uffdd\064\uffdd\001\002\000\042\004\135\005\141\011\uffe0" +
    "\022\uffe0\023\uffe0\025\uffe0\031\uffe0\034\uffe0\035\uffe0\036" +
    "\uffe0\044\uffe0\050\uffe0\054\uffe0\062\uffe0\063\uffe0\064\uffe0" +
    "\001\002\000\042\004\135\005\141\011\uffe5\022\uffe5\023" +
    "\uffe5\025\uffe5\031\uffe5\034\uffe5\035\uffe5\036\uffe5\044\uffe5" +
    "\050\uffe5\054\uffe5\062\uffe5\063\uffe5\064\uffe5\001\002\000" +
    "\042\004\135\005\141\011\uffe3\022\uffe3\023\uffe3\025\uffe3" +
    "\031\uffe3\034\uffe3\035\uffe3\036\uffe3\044\uffe3\050\uffe3\054" +
    "\uffe3\062\uffe3\063\uffe3\064\uffe3\001\002\000\064\004\uffde" +
    "\005\uffde\006\112\007\113\011\uffde\014\uffde\015\uffde\016" +
    "\uffde\017\uffde\020\uffde\021\uffde\022\uffde\023\uffde\025\uffde" +
    "\031\uffde\033\uffde\034\uffde\035\uffde\036\uffde\044\uffde\050" +
    "\uffde\054\uffde\062\uffde\063\uffde\064\uffde\001\002\000\042" +
    "\004\135\005\141\011\uffe2\022\uffe2\023\uffe2\025\uffe2\031" +
    "\uffe2\034\uffe2\035\uffe2\036\uffe2\044\uffe2\050\uffe2\054\uffe2" +
    "\062\uffe2\063\uffe2\064\uffe2\001\002\000\042\004\135\005" +
    "\141\011\uffe1\022\uffe1\023\uffe1\025\uffe1\031\uffe1\034\uffe1" +
    "\035\uffe1\036\uffe1\044\uffe1\050\uffe1\054\uffe1\062\uffe1\063" +
    "\uffe1\064\uffe1\001\002\000\042\004\135\005\141\011\uffe4" +
    "\022\uffe4\023\uffe4\025\uffe4\031\uffe4\034\uffe4\035\uffe4\036" +
    "\uffe4\044\uffe4\050\uffe4\054\uffe4\062\uffe4\063\uffe4\064\uffe4" +
    "\001\002\000\064\004\uffd8\005\uffd8\006\uffd8\007\uffd8\011" +
    "\uffd8\014\uffd8\015\uffd8\016\uffd8\017\uffd8\020\uffd8\021\uffd8" +
    "\022\uffd8\023\uffd8\025\uffd8\031\uffd8\033\uffd8\034\uffd8\035" +
    "\uffd8\036\uffd8\044\uffd8\050\uffd8\054\uffd8\062\uffd8\063\uffd8" +
    "\064\uffd8\001\002\000\004\011\154\001\002\000\064\004" +
    "\uffc6\005\uffc6\006\uffc6\007\uffc6\011\uffc6\014\uffc6\015\uffc6" +
    "\016\uffc6\017\uffc6\020\uffc6\021\uffc6\022\uffc6\023\uffc6\025" +
    "\uffc6\031\uffc6\033\uffc6\034\uffc6\035\uffc6\036\uffc6\044\uffc6" +
    "\050\uffc6\054\uffc6\062\uffc6\063\uffc6\064\uffc6\001\002\000" +
    "\006\011\156\023\122\001\002\000\064\004\uffd4\005\uffd4" +
    "\006\uffd4\007\uffd4\011\uffd4\014\uffd4\015\uffd4\016\uffd4\017" +
    "\uffd4\020\uffd4\021\uffd4\022\uffd4\023\uffd4\025\uffd4\031\uffd4" +
    "\033\uffd4\034\uffd4\035\uffd4\036\uffd4\044\uffd4\050\uffd4\054" +
    "\uffd4\062\uffd4\063\uffd4\064\uffd4\001\002\000\004\065\160" +
    "\001\002\000\016\025\034\035\047\036\045\044\036\054" +
    "\041\062\042\001\002\000\024\025\034\034\164\035\047" +
    "\036\045\044\036\054\041\062\042\063\163\064\162\001" +
    "\002\000\004\010\204\001\002\000\004\065\201\001\002" +
    "\000\026\025\uffc3\034\uffc3\035\uffc3\036\uffc3\044\uffc3\050" +
    "\uffc3\054\uffc3\062\uffc3\063\uffc3\064\uffc3\001\002\000\010" +
    "\034\170\063\166\064\167\001\002\000\004\065\176\001" +
    "\002\000\004\010\171\001\002\000\026\025\uffc1\034\uffc1" +
    "\035\uffc1\036\uffc1\044\uffc1\050\uffc1\054\uffc1\062\uffc1\063" +
    "\uffc1\064\uffc1\001\002\000\034\005\064\010\060\024\055" +
    "\041\067\043\072\051\074\052\102\053\101\054\104\056" +
    "\062\057\103\060\105\061\057\001\002\000\006\011\173" +
    "\023\122\001\002\000\004\065\174\001\002\000\016\025" +
    "\034\035\047\036\045\044\036\054\041\062\042\001\002" +
    "\000\024\025\034\034\uffbf\035\047\036\045\044\036\054" +
    "\041\062\042\063\uffbf\064\uffbf\001\002\000\016\025\034" +
    "\035\047\036\045\044\036\054\041\062\042\001\002\000" +
    "\020\025\034\034\200\035\047\036\045\044\036\054\041" +
    "\062\042\001\002\000\026\025\uffc0\034\uffc0\035\uffc0\036" +
    "\uffc0\044\uffc0\050\uffc0\054\uffc0\062\uffc0\063\uffc0\064\uffc0" +
    "\001\002\000\016\025\034\035\047\036\045\044\036\054" +
    "\041\062\042\001\002\000\020\025\034\034\203\035\047" +
    "\036\045\044\036\054\041\062\042\001\002\000\026\025" +
    "\uffc2\034\uffc2\035\uffc2\036\uffc2\044\uffc2\050\uffc2\054\uffc2" +
    "\062\uffc2\063\uffc2\064\uffc2\001\002\000\034\005\064\010" +
    "\060\024\055\041\067\043\072\051\074\052\102\053\101" +
    "\054\104\056\062\057\103\060\105\061\057\001\002\000" +
    "\006\011\206\023\122\001\002\000\004\065\207\001\002" +
    "\000\016\025\034\035\047\036\045\044\036\054\041\062" +
    "\042\001\002\000\024\025\034\034\uffbe\035\047\036\045" +
    "\044\036\054\041\062\042\063\uffbe\064\uffbe\001\002\000" +
    "\036\011\uffe7\022\uffe7\023\uffe7\025\uffe7\031\uffe7\034\uffe7" +
    "\035\uffe7\036\uffe7\044\uffe7\050\uffe7\054\uffe7\062\uffe7\063" +
    "\uffe7\064\uffe7\001\002\000\034\005\uffed\010\uffed\024\uffed" +
    "\041\uffed\043\uffed\051\uffed\052\uffed\053\uffed\054\uffed\056" +
    "\uffed\057\uffed\060\uffed\061\uffed\001\002\000\034\005\064" +
    "\010\060\024\055\041\067\043\072\051\074\052\102\053" +
    "\101\054\104\056\062\057\103\060\105\061\057\001\002" +
    "\000\030\023\122\025\uffec\034\uffec\035\uffec\036\uffec\044" +
    "\uffec\050\uffec\054\uffec\062\uffec\063\uffec\064\uffec\001\002" +
    "\000\034\005\064\010\060\024\055\041\067\043\072\051" +
    "\074\052\102\053\101\054\104\056\062\057\103\060\105" +
    "\061\057\001\002\000\006\011\217\023\122\001\002\000" +
    "\026\025\uffca\034\uffca\035\uffca\036\uffca\044\uffca\050\uffca" +
    "\054\uffca\062\uffca\063\uffca\064\uffca\001\002\000\004\054" +
    "\221\001\002\000\004\055\222\001\002\000\004\052\223" +
    "\001\002\000\004\033\224\001\002\000\004\054\225\001" +
    "\002\000\006\004\226\005\227\001\002\000\034\004\241" +
    "\005\064\010\060\041\067\043\072\051\074\052\102\053" +
    "\101\054\104\056\062\057\103\060\105\061\057\001\002" +
    "\000\032\005\237\010\060\041\067\043\072\051\074\052" +
    "\102\053\101\054\104\056\062\057\103\060\105\061\057" +
    "\001\002\000\004\033\231\001\002\000\032\005\064\010" +
    "\060\041\067\043\072\051\074\052\102\053\101\054\104" +
    "\056\062\057\103\060\105\061\057\001\002\000\004\011" +
    "\233\001\002\000\004\026\234\001\002\000\016\025\034" +
    "\035\047\036\045\044\036\054\041\062\042\001\002\000" +
    "\020\025\034\034\236\035\047\036\045\044\036\054\041" +
    "\062\042\001\002\000\026\025\uffb9\034\uffb9\035\uffb9\036" +
    "\uffb9\044\uffb9\050\uffb9\054\uffb9\062\uffb9\063\uffb9\064\uffb9" +
    "\001\002\000\034\005\064\010\060\033\uffba\041\067\043" +
    "\072\051\074\052\102\053\101\054\104\056\062\057\103" +
    "\060\105\061\057\001\002\000\010\004\135\005\141\033" +
    "\uffbc\001\002\000\004\033\uffbb\001\002\000\010\004\135" +
    "\005\141\033\uffbd\001\002\000\004\002\001\001\002\000" +
    "\004\002\000\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\242\000\010\002\004\005\006\006\003\001\001\000" +
    "\004\005\243\001\001\000\002\001\001\000\016\007\043" +
    "\010\034\011\036\012\045\013\037\014\042\001\001\000" +
    "\002\001\001\000\006\003\010\004\011\001\001\000\002" +
    "\001\001\000\006\003\031\004\011\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\035\017" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\035\024" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\035" +
    "\027\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\014\010\047\011\036\012\045\013\037\014\042\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\036\015\055\016\070" +
    "\017\064\020\075\021\077\022\067\023\076\024\072\025" +
    "\074\026\060\027\065\030\062\031\052\032\053\001\001" +
    "\000\002\001\001\000\002\001\001\000\032\016\070\020" +
    "\210\021\077\022\067\023\076\024\072\025\074\026\060" +
    "\027\065\030\062\031\052\032\053\001\001\000\002\001" +
    "\001\000\002\001\001\000\036\015\154\016\070\017\064" +
    "\020\075\021\077\022\067\023\076\024\072\025\074\026" +
    "\060\027\065\030\062\031\052\032\053\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\022\016" +
    "\070\024\151\025\074\026\060\027\065\030\062\031\052" +
    "\032\053\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\022\016" +
    "\070\024\114\025\074\026\060\027\065\030\062\031\052" +
    "\032\053\001\001\000\022\016\070\024\113\025\074\026" +
    "\060\027\065\030\062\031\052\032\053\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\037\116\001\001\000" +
    "\036\015\117\016\070\017\064\020\075\021\077\022\067" +
    "\023\076\024\072\025\074\026\060\027\065\030\062\031" +
    "\052\032\053\001\001\000\002\001\001\000\002\001\001" +
    "\000\034\016\070\017\122\020\075\021\077\022\067\023" +
    "\076\024\072\025\074\026\060\027\065\030\062\031\052" +
    "\032\053\001\001\000\002\001\001\000\032\016\070\020" +
    "\124\021\077\022\067\023\076\024\072\025\074\026\060" +
    "\027\065\030\062\031\052\032\053\001\001\000\002\001" +
    "\001\000\004\035\126\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\026\016\070\022\150\023" +
    "\076\024\072\025\074\026\060\027\065\030\062\031\052" +
    "\032\053\001\001\000\026\016\070\022\147\023\076\024" +
    "\072\025\074\026\060\027\065\030\062\031\052\032\053" +
    "\001\001\000\026\016\070\022\146\023\076\024\072\025" +
    "\074\026\060\027\065\030\062\031\052\032\053\001\001" +
    "\000\024\016\070\023\145\024\072\025\074\026\060\027" +
    "\065\030\062\031\052\032\053\001\001\000\026\016\070" +
    "\022\144\023\076\024\072\025\074\026\060\027\065\030" +
    "\062\031\052\032\053\001\001\000\026\016\070\022\143" +
    "\023\076\024\072\025\074\026\060\027\065\030\062\031" +
    "\052\032\053\001\001\000\026\016\070\022\142\023\076" +
    "\024\072\025\074\026\060\027\065\030\062\031\052\032" +
    "\053\001\001\000\024\016\070\023\141\024\072\025\074" +
    "\026\060\027\065\030\062\031\052\032\053\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\016\007\160\010\034\011\036\012\045" +
    "\013\037\014\042\001\001\000\016\010\047\011\036\012" +
    "\045\013\037\014\042\034\164\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\036" +
    "\015\171\016\070\017\064\020\075\021\077\022\067\023" +
    "\076\024\072\025\074\026\060\027\065\030\062\031\052" +
    "\032\053\001\001\000\002\001\001\000\002\001\001\000" +
    "\016\007\174\010\034\011\036\012\045\013\037\014\042" +
    "\001\001\000\014\010\047\011\036\012\045\013\037\014" +
    "\042\001\001\000\016\007\176\010\034\011\036\012\045" +
    "\013\037\014\042\001\001\000\014\010\047\011\036\012" +
    "\045\013\037\014\042\001\001\000\002\001\001\000\016" +
    "\007\201\010\034\011\036\012\045\013\037\014\042\001" +
    "\001\000\014\010\047\011\036\012\045\013\037\014\042" +
    "\001\001\000\002\001\001\000\036\015\204\016\070\017" +
    "\064\020\075\021\077\022\067\023\076\024\072\025\074" +
    "\026\060\027\065\030\062\031\052\032\053\001\001\000" +
    "\002\001\001\000\002\001\001\000\016\007\207\010\034" +
    "\011\036\012\045\013\037\014\042\001\001\000\014\010" +
    "\047\011\036\012\045\013\037\014\042\001\001\000\002" +
    "\001\001\000\004\036\212\001\001\000\036\015\213\016" +
    "\070\017\064\020\075\021\077\022\067\023\076\024\072" +
    "\025\074\026\060\027\065\030\062\031\052\032\053\001" +
    "\001\000\002\001\001\000\036\015\215\016\070\017\064" +
    "\020\075\021\077\022\067\023\076\024\072\025\074\026" +
    "\060\027\065\030\062\031\052\032\053\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\033\227\001\001\000\026\016\070\022\241\023" +
    "\076\024\072\025\074\026\060\027\065\030\062\031\052" +
    "\032\053\001\001\000\026\016\070\022\237\023\076\024" +
    "\072\025\074\026\060\027\065\030\062\031\052\032\053" +
    "\001\001\000\002\001\001\000\030\016\070\021\231\022" +
    "\067\023\076\024\072\025\074\026\060\027\065\030\062" +
    "\031\052\032\053\001\001\000\002\001\001\000\002\001" +
    "\001\000\016\007\234\010\034\011\036\012\045\013\037" +
    "\014\042\001\001\000\014\010\047\011\036\012\045\013" +
    "\037\014\042\001\001\000\002\001\001\000\022\016\070" +
    "\024\151\025\074\026\060\027\065\030\062\031\052\032" +
    "\053\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$MiParser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$MiParser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$MiParser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}





    boolean is_sentencia_for = false;

    Boolean isGuionBajoFilter = false;

    Boolean isConstante= false;

    Boolean isExpresionFilter = false;

    ArrayList<Literal> constantesFilter = new ArrayList<>();

    List<String> produccionesRecorridas = new ArrayList<>();
    
    Boolean isAsignacionFilter = false;
    String idAsignacionFilter; 
    String returnFilter;
    ArrayList<String> lista_varFilter = new ArrayList<String>();

    public List<String> getProduccionesList(){
        return this.produccionesRecorridas;
    }

    public boolean validarTiposVariablesConExpresion(String var, Expresion expresion_or){
        boolean retorno=true;
        Tipo tipoAuxVar = ht.get(var);
        if(expresion_or.getTipo() != tipoAuxVar){
            if((expresion_or.getTipo() == Tipo.BOOLEAN && tipoAuxVar == Tipo.INTEGER) || (expresion_or.getTipo() == Tipo.INTEGER && tipoAuxVar ==Tipo.BOOLEAN) || (expresion_or.getTipo() == Tipo.FLOAT && tipoAuxVar ==Tipo.BOOLEAN) || (expresion_or.getTipo() == Tipo.BOOLEAN && tipoAuxVar == Tipo.FLOAT) ){
                retorno = false;
            }
        }
        
        return retorno;
    }
    
    public boolean validarTiposVariablesConTipoAsignacionId(String var){
        boolean retorno = true;
        Tipo tipoIdAsignacion = ht.get(idAsignacionFilter);
        
        Tipo tipoAuxVar = ht.get(var);
        if(tipoIdAsignacion == Tipo.BOOLEAN &&  tipoAuxVar != Tipo.BOOLEAN){
            retorno = false;
        }else if((tipoIdAsignacion == Tipo.INTEGER || tipoIdAsignacion == Tipo.FLOAT) && tipoAuxVar == Tipo.BOOLEAN){
            retorno = false;
        }else if(tipoIdAsignacion == Tipo.INTEGER && (tipoAuxVar == Tipo.BOOLEAN || tipoIdAsignacion == Tipo.FLOAT)){
            retorno = false;
        }
     
        return retorno;
    }

    
   

    public String printProduccionesRecorridas(List<String> misProducciones){
        String textoConcat = "";
        textoConcat = textoConcat.concat("Pasó por las siguientes reglas:\n");
        for(String txt : misProducciones){
            textoConcat = textoConcat.concat(txt).concat("\n");
        }
        return textoConcat;
    }

    Hashtable<String, Tipo> ht = new Hashtable<String, Tipo>();

    public Hashtable<String, Tipo> getSymbolTable(){
        return this.ht;
    }

    Hashtable<String, Constante> htValor = new Hashtable<String, Constante>();

    public Hashtable<String, Constante> getValueTable(){
        return this.htValor;
    }

    public void printHt(Hashtable<String, Tipo> ht){
        ht.forEach((k, v) -> {
            System.out.println("Tabla de simbolos: " + k.toString() + " " + Tipo.toString(v));
        });
    }
    public String concatHt(Hashtable<String, Tipo> ht){
        Iterator<String> iterator = ht.keySet().iterator();
        String concatenado = "\nTabla de simbolos:\n";

        while(iterator.hasNext()) {
            String clave = iterator.next();
            Tipo tipo = ht.get(clave);
            concatenado += clave.concat(" -> ").concat(Tipo.toString(tipo)).concat("\n");
        }
        return concatenado;
    }

    private String s;

    public void syntax_error(Symbol s){
        this.s="Error en la linea "+ (s.right+1)+ " Columna "+ (s.left+1)+ ". Valor simbolo '"
        +s.value+"' . Simbolo n° "+s.sym+ " no reconocido.";
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        this.s="Error en la linea "+ (s.right+1)+ " Columna "+ (s.left+1)+ ". Valor simbolo '"
        +s.value+"' . Simbolo n° "+s.sym+ " no reconocido." ;
    }

    public String getS(){
        return this.s;
    }


/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$MiParser$actions {



  private final MiParser parser;

  /** Constructor */
  CUP$MiParser$actions(MiParser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$MiParser$do_action_part00000000(
    int                        CUP$MiParser$act_num,
    java_cup.runtime.lr_parser CUP$MiParser$parser,
    java.util.Stack            CUP$MiParser$stack,
    int                        CUP$MiParser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$MiParser$result;

      /* select the action based on the action number */
      switch (CUP$MiParser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= programa EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		Programa start_val = (Programa)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		RESULT = start_val;
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$MiParser$parser.done_parsing();
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // programa ::= bloque_declaraciones bloque_programa 
            {
              Programa RESULT =null;
		int bdleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int bdright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		ArrayList<ArrayList<Declaracion>> bd = (ArrayList<ArrayList<Declaracion>>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		int bpleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int bpright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		ArrayList<Sentencia> bp = (ArrayList<Sentencia>)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("programa ->");
        RESULT = new Programa(bp,bd);
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("programa",0, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // programa ::= bloque_programa 
            {
              Programa RESULT =null;
		int bpleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int bpright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		ArrayList<Sentencia> bp = (ArrayList<Sentencia>)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("programa ->");
        RESULT = new Programa(bp);

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("programa",0, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // bloque_declaraciones ::= DECLARE_SECTION declaraciones END_DECLARE_SECTION 
            {
              ArrayList<ArrayList<Declaracion>> RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		ArrayList<ArrayList<Declaracion>> d = (ArrayList<ArrayList<Declaracion>>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		
        produccionesRecorridas.add("bloque_declaraciones -> DECLARE_SECTION declaraciones END_DECLARE_SECTION");
        RESULT  = d;

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("bloque_declaraciones",4, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // declaraciones ::= declaracion declaraciones 
            {
              ArrayList<ArrayList<Declaracion>> RESULT =null;
		int decleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int decright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		ArrayList<Declaracion> dec = (ArrayList<Declaracion>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		int decsleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int decsright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		ArrayList<ArrayList<Declaracion>> decs = (ArrayList<ArrayList<Declaracion>>)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("declaraciones -> declaracion declaraciones");
        decs.add(dec);
        RESULT = decs;
   
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("declaraciones",1, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // declaraciones ::= declaracion 
            {
              ArrayList<ArrayList<Declaracion>> RESULT =null;
		int decleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int decright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		ArrayList<Declaracion> dec = (ArrayList<Declaracion>)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("declaraciones -> declaracion");
        ArrayList<ArrayList<Declaracion>> declaracionesRegla = new ArrayList<ArrayList<Declaracion>>();
        declaracionesRegla.add(dec);
        RESULT = declaracionesRegla;
        

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("declaraciones",1, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // lista_var ::= lista_var COMA VAR 
            {
              ArrayList<String> RESULT =null;
		int l_vleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).left;
		int l_vright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).right;
		ArrayList<String> l_v = (ArrayList<String>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("lista_var -> lista_var COMA VAR");
        l_v.add(id);

        RESULT = l_v;
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("lista_var",27, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // lista_var ::= VAR 
            {
              ArrayList<String> RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("lista_var -> VAR");
        ArrayList<String> ident = new ArrayList<String>();
        ident.add(id);
        RESULT = ident;

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("lista_var",27, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // declaracion ::= INT_TYPE DOS_PUNTOS lista_var PUNTO_COMA 
            {
              ArrayList<Declaracion> RESULT =null;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-3)).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-3)).right;
		String tipo = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-3)).value;
		int l_vleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int l_vright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		ArrayList<String> l_v = (ArrayList<String>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		
        produccionesRecorridas.add("declaracion -> INT_TYPE DOS_PUNTOS lista_var PUNTO_COMA");
        ArrayList<Declaracion> declaraciones = new ArrayList<>();
        for(String i : l_v){
            if(ht.containsKey(i)){
                throw new VarAlreadyExistTSException("La variable "+i+" ya esta definida\n");
            }
            else{
                ht.put(i,Tipo.INTEGER);
                declaraciones.add(new Declaracion(Tipo.INTEGER, new Identificador(i, Tipo.INTEGER)));
            }
        }
        RESULT = declaraciones;
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("declaracion",2, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-3)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // declaracion ::= FLOAT_TYPE DOS_PUNTOS lista_var PUNTO_COMA 
            {
              ArrayList<Declaracion> RESULT =null;
		int l_vleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int l_vright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		ArrayList<String> l_v = (ArrayList<String>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		
        produccionesRecorridas.add("declaracion -> FLOAT_TYPE DOS_PUNTOS lista_var PUNTO_COMA");
        ArrayList<Declaracion> declaraciones = new ArrayList<>();
        for(String i : l_v){
            if(ht.containsKey(i)){
                throw new VarAlreadyExistTSException("La variable "+i+" ya esta definida\n");
            }
            else{
                ht.put(i,Tipo.FLOAT);
                declaraciones.add(new Declaracion(Tipo.FLOAT, new Identificador(i, Tipo.FLOAT)));
            }
        }
        RESULT = declaraciones;
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("declaracion",2, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-3)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // declaracion ::= BOOLEAN_TYPE DOS_PUNTOS lista_var PUNTO_COMA 
            {
              ArrayList<Declaracion> RESULT =null;
		int l_vleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int l_vright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		ArrayList<String> l_v = (ArrayList<String>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		
        produccionesRecorridas.add("declaracion -> BOOLEAN_TYPE DOS_PUNTOS lista_var PUNTO_COMA");
        ArrayList<Declaracion> declaraciones = new ArrayList<>();
        for(String i : l_v){
            if(ht.containsKey(i)){
                throw new VarAlreadyExistTSException("La variable "+i+" ya esta definida\n");
            
            }
            else{
                ht.put(i,Tipo.BOOLEAN);
                declaraciones.add(new Declaracion(Tipo.BOOLEAN, new Identificador(i, Tipo.BOOLEAN)));
                
            }
        }
        RESULT = declaraciones;

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("declaracion",2, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-3)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // bloque_programa ::= PROGRAM_SECTION bloque_sentencias END_PROGRAM_SECTION 
            {
              ArrayList<Sentencia> RESULT =null;
		int bsleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int bsright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		ArrayList<Sentencia> bs = (ArrayList<Sentencia>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		
    produccionesRecorridas.add("bloque_programa -> PROGRAM_SECTION bloque_sentencias END_PROGRAM_SECTION");
    RESULT = bs;

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("bloque_programa",3, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // bloque_sentencias ::= bloque_sentencias sentencia 
            {
              ArrayList<Sentencia> RESULT =null;
		int bsleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int bsright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		ArrayList<Sentencia> bs = (ArrayList<Sentencia>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Sentencia s = (Sentencia)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            produccionesRecorridas.add("bloque_sentencias -> bloque_sentencias:bs sentencia");
            bs.add(s);
            RESULT = bs;
       
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("bloque_sentencias",5, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // bloque_sentencias ::= sentencia 
            {
              ArrayList<Sentencia> RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Sentencia s = (Sentencia)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            produccionesRecorridas.add("bloque_sentencias -> sentencia");
            ArrayList<Sentencia> sentencias = new ArrayList<>();
            sentencias.add(s);
            RESULT  = sentencias;

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("bloque_sentencias",5, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // sentencia ::= sentencia_for 
            {
              Sentencia RESULT =null;
		int sfleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int sfright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Sentencia sf = (Sentencia)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            is_sentencia_for = true;
            produccionesRecorridas.add("sentencia -> sentencia_for");
            RESULT = sf;
       
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("sentencia",6, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // sentencia ::= sentencia_if 
            {
              Sentencia RESULT =null;
		int sifleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int sifright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Sentencia sif = (Sentencia)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            produccionesRecorridas.add("sentencia -> sentencia_if");
            RESULT = sif;
       
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("sentencia",6, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // sentencia ::= sentencia_asignacion 
            {
              Sentencia RESULT =null;
		int saleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int saright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Sentencia sa = (Sentencia)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            produccionesRecorridas.add("sentencia -> sentencia_asignacion");
            RESULT = sa;
       
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("sentencia",6, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // sentencia ::= sentencia_display 
            {
              Sentencia RESULT =null;
		int sdleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int sdright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Sentencia sd = (Sentencia)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            produccionesRecorridas.add("sentencia -> sentencia_display");
            RESULT = sd;
        
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("sentencia",6, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // sentencia ::= BREAK 
            {
              Sentencia RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		String b = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            if(!is_sentencia_for){
                throw new Exception("El BREAK no se encuentra dentro del FOR");
            }
            produccionesRecorridas.add("sentencia -> BREAK");
            RESULT = new Break(); 
        
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("sentencia",6, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // sentencia ::= CONTINUE 
            {
              Sentencia RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            if(!is_sentencia_for){
                throw new Exception("El CONTINUE no se encuentra dentro del FOR");
            }
            produccionesRecorridas.add("sentencia -> CONTINUE");
            RESULT = new Continue();

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("sentencia",6, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // NT$0 ::= 
            {
              Sentencia RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;


    isAsignacionFilter= true;
    idAsignacionFilter = id;
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("NT$0",28, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // sentencia_asignacion ::= VAR ASIGNACION NT$0 expresion_or 
            {
              Sentencia RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Sentencia) ((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-3)).value;
		int eoleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int eoright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion eo = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("sentencia_asignacion -> VAR ASIGNACION expresion_or");


        if(!ht.containsKey(id)){
            throw new VarNotDeclaredTSException("La variable "+(String) id+" no está declarada previamente.");
        }
        Tipo tipoId = ht.get(id);
        RESULT = new Asignacion(new Identificador(id, tipoId),eo);

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("sentencia_asignacion",9, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-3)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // expresion_or ::= expresion_or OPERADOR_OR expresion_and 
            {
              Expresion RESULT =null;
		int eoleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).left;
		int eoright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).right;
		Expresion eo = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).value;
		int ealeft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int earight = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion ea = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("expresion_or -> expresion_or OPERADOR_OR expresion_and");

        if(eo.getTipo() == Tipo.BOOLEAN && ea.getTipo() == Tipo.BOOLEAN){
            if (isExpresionFilter){
                RESULT =new ExpresionFilter(eo,ea,Tipo.BOOLEAN);
            }else{
                RESULT =new Or(eo,ea);
            }
        }
        else{
            throw new Exception("No se puede realizar la expresion OR entre una variable del tipo " + Tipo.toString(eo.getTipo()) + " y una variable de tipo " + Tipo.toString(ea.getTipo()));
        }
       
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("expresion_or",11, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // expresion_or ::= expresion_and 
            {
              Expresion RESULT =null;
		int ealeft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int earight = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion ea = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            produccionesRecorridas.add("expresion_or -> expresion_and");
            RESULT = ea; 

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("expresion_or",11, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // expresion_and ::= expresion_and OPERADOR_AND expresion_not 
            {
              Expresion RESULT =null;
		int ealeft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).left;
		int earight = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).right;
		Expresion ea = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).value;
		int enleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int enright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion en = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("expresion_and -> expresion_and OPERADOR_AND expresion_not");
        if(ea.getTipo() == Tipo.BOOLEAN && en.getTipo() == Tipo.BOOLEAN){
            if (isExpresionFilter){
                RESULT =new ExpresionFilter(ea,en,Tipo.BOOLEAN);
            }else{
                RESULT =new And(ea,en);
            }
        }
        else{
            throw new Exception("No se puede realizar la expresion AND entre una variable del tipo " + Tipo.toString(ea.getTipo()) + " y una variable de tipo " + Tipo.toString(en.getTipo()));
        }
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("expresion_and",13, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // expresion_and ::= expresion_not 
            {
              Expresion RESULT =null;
		int enleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int enright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion en = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("expresion_and -> expresion_not");
        RESULT = en;

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("expresion_and",13, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // expresion_not ::= OPERADOR_NOT expresion_not 
            {
              Expresion RESULT =null;
		int enleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int enright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion en = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("expresion_not -> OPERADOR_NOT expresion_not");
        if(en.getTipo() == Tipo.BOOLEAN){
            if (isExpresionFilter){
                RESULT =new ExpresionFilter(new NegacionLogica(en),en,Tipo.BOOLEAN);
            }else{
                RESULT =new NegacionLogica(en);
            }
        }
        else{
            throw new Exception("No se puede realizar la expresion NOT con una variable del tipo " +  Tipo.toString(en.getTipo()));
        }        
       
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("expresion_not",14, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // expresion_not ::= comparacion 
            {
              Expresion RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion c = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("expresion_not -> comparacion");
        RESULT = c;

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("expresion_not",14, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // comparacion ::= expresion_sr OPERADOR_MAYOR expresion_sr 
            {
              Expresion RESULT =null;
		int esr1left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).left;
		int esr1right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).right;
		Expresion esr1 = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).value;
		int esr2left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int esr2right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion esr2 = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_MAYOR expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,Tipo.INTEGER);
                }else{
                    RESULT = new Mayor(esr1,esr2);
                }
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,flotante,Tipo.FLOAT);
                }else{
                    RESULT = new Mayor(esr1,flotante);
                }
            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(flotante,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new Mayor(flotante,esr2);
                }

            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new Mayor(esr1,esr2);
                }
            }
            else if(isGuionBajoFilter && (esr2.getTipo() == Tipo.FLOAT || esr2.getTipo() == Tipo.INTEGER)){
                esr1.setTipo(esr2.getTipo());
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,esr2.getTipo());
                }else{
                    RESULT = new Mayor(esr1,esr2);
                }
            }
            else{
                throw new Exception("La variable de tipo " + Tipo.toString(esr1.getTipo()) + " no puede compararse con el operador > con una variable del tipo " + Tipo.toString(esr2.getTipo()));
            }
       
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("comparacion",15, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // comparacion ::= expresion_sr OPERADOR_MAYOR_IGUAL expresion_sr 
            {
              Expresion RESULT =null;
		int esr1left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).left;
		int esr1right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).right;
		Expresion esr1 = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).value;
		int esr2left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int esr2right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion esr2 = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_MAYOR_IGUAL expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){          
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,Tipo.INTEGER);
                }else{
                    RESULT = new MayorIgual(esr1,esr2);
                };
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,flotante,Tipo.FLOAT);
                }else{
                    RESULT = new MayorIgual(esr1,flotante);
                };
            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(flotante,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new MayorIgual(flotante,esr2);
                };
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new MayorIgual(esr1,esr2);
                };
            }
            else if(isGuionBajoFilter && (esr2.getTipo() == Tipo.FLOAT || esr2.getTipo() == Tipo.INTEGER)){
                esr1.setTipo(esr2.getTipo());
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,esr2.getTipo());
                }else{
                    RESULT = new MayorIgual(esr1,esr2);
                };
            }
            else{
                throw new Exception("La variable de tipo " + Tipo.toString(esr1.getTipo()) + " no puede compararse con el operador >= con una variable del tipo " + Tipo.toString(esr2.getTipo()));
            }
       
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("comparacion",15, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // comparacion ::= expresion_sr OPERADOR_MENOR expresion_sr 
            {
              Expresion RESULT =null;
		int esr1left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).left;
		int esr1right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).right;
		Expresion esr1 = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).value;
		int esr2left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int esr2right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion esr2 = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_MENOR expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,Tipo.INTEGER);
                }else{
                    RESULT = new Menor(esr1,esr2);
                };
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,flotante,Tipo.FLOAT);
                }else{
                    RESULT = new Menor(esr1,flotante);
                };
            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(flotante,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new Menor(flotante,esr2);
                };
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new Menor(esr1,esr2);
                };
            }
            else if(isGuionBajoFilter && (esr2.getTipo() == Tipo.FLOAT || esr2.getTipo() == Tipo.INTEGER)){
                esr1.setTipo(esr2.getTipo());
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,esr2.getTipo());
                }else{
                    RESULT = new Menor(esr1,esr2);
                };
            }
            else{
                throw new Exception("La variable de tipo " + Tipo.toString(esr1.getTipo()) + " no puede compararse con el operador < con una variable del tipo " + Tipo.toString(esr2.getTipo()));
            }
       
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("comparacion",15, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // comparacion ::= expresion_sr OPERADOR_MENOR_IGUAL expresion_sr 
            {
              Expresion RESULT =null;
		int esr1left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).left;
		int esr1right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).right;
		Expresion esr1 = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).value;
		int esr2left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int esr2right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion esr2 = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_MENOR_IGUAL expresion_s");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,Tipo.INTEGER);
                }else{
                    RESULT = new MenorIgual(esr1,esr2);
                };
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,flotante,Tipo.FLOAT);
                }else{
                    RESULT = new MenorIgual(esr1,flotante);
                };
            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(flotante,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new MenorIgual(flotante,esr2);
                };
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new MenorIgual(esr1,esr2);
                };
            }
            else if(isGuionBajoFilter && (esr2.getTipo() == Tipo.FLOAT || esr2.getTipo() == Tipo.INTEGER)){
                esr1.setTipo(esr2.getTipo());
                if (isExpresionFilter){
                    RESULT = new ExpresionFilter(esr1,esr2,esr2.getTipo());
                }else{
                    RESULT = new MenorIgual(esr1,esr2);                
                };
            }
            else{
                throw new Exception("La variable de tipo " + Tipo.toString(esr1.getTipo()) + " no puede compararse con el operador < con una variable del tipo " + Tipo.toString(esr2.getTipo()));
            }
       
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("comparacion",15, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // comparacion ::= expresion_sr OPERADOR_IGUAL expresion_sr 
            {
              Expresion RESULT =null;
		int esr1left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).left;
		int esr1right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).right;
		Expresion esr1 = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).value;
		int esr2left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int esr2right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion esr2 = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_IGUAL expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,esr2,Tipo.INTEGER);
                }else{
                    RESULT = new Igualdad(esr1,esr2);
                };
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,flotante,Tipo.FLOAT);
                }else{
                    RESULT = new Igualdad(esr1,flotante);
                };
            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(flotante,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new Igualdad(flotante,esr2);
                };
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new Igualdad(esr1,esr2);
                };
            }
            else if(esr1.getTipo() == Tipo.BOOLEAN && esr2.getTipo() == Tipo.BOOLEAN){
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,esr2,Tipo.BOOLEAN);
                }else{
                    RESULT = new Igualdad(esr1,esr2);
                };
            }
            else if(isGuionBajoFilter && (esr2.getTipo() == Tipo.FLOAT || esr2.getTipo() == Tipo.INTEGER || esr2.getTipo() == Tipo.BOOLEAN)){
                esr1.setTipo(esr2.getTipo());
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,esr2,esr2.getTipo());
                }else{
                    RESULT = new Igualdad(esr1,esr2);
                };
            }
            else{
                throw new Exception("La variable de tipo " + Tipo.toString(esr1.getTipo()) + " no puede compararse con el operador == con una variable del tipo " + Tipo.toString(esr2.getTipo()));
            }
       
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("comparacion",15, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // comparacion ::= expresion_sr OPERADOR_DISTINTO expresion_sr 
            {
              Expresion RESULT =null;
		int esr1left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).left;
		int esr1right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).right;
		Expresion esr1 = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).value;
		int esr2left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int esr2right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion esr2 = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            produccionesRecorridas.add("comparacion -> expresion_sr OPERADOR_DISTINTO expresion_sr");
            if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.INTEGER){
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,esr2,Tipo.INTEGER);
                }else{
                    RESULT = new Desigualdad(esr1,esr2);
                };
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(esr2);
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,flotante,Tipo.FLOAT);
                }else{
                    RESULT = new Desigualdad(esr1,flotante);
                };
            }
            else if(esr1.getTipo() == Tipo.INTEGER && esr2.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr1);
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(flotante,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new Desigualdad(flotante,esr2);
                };
            }
            else if(esr1.getTipo() == Tipo.FLOAT && esr2.getTipo() == Tipo.FLOAT){
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,esr2,Tipo.FLOAT);
                }else{
                    RESULT = new Desigualdad(esr1,esr2);
                };
            }
            else if(esr1.getTipo() == Tipo.BOOLEAN && esr2.getTipo() == Tipo.BOOLEAN){
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,esr2,Tipo.BOOLEAN);
                }else{
                    RESULT = new Desigualdad(esr1,esr2);
                };
            }
            else if(isGuionBajoFilter && (esr2.getTipo() == Tipo.FLOAT || esr2.getTipo() == Tipo.INTEGER || esr2.getTipo() == Tipo.BOOLEAN)){
                esr1.setTipo(esr2.getTipo());
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr1,esr2,esr2.getTipo());
                }else{
                    RESULT = new Desigualdad(esr1,esr2);
                };
            }
            else{
                throw new Exception("La variable de tipo " + Tipo.toString(esr1.getTipo()) + " no puede compararse con el operador != con una variable del tipo " + Tipo.toString(esr2.getTipo()));
            }
       
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("comparacion",15, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // comparacion ::= expresion_sr 
            {
              Expresion RESULT =null;
		int esrleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int esrright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion esr = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            produccionesRecorridas.add("comparacion -> expresion_sr");
            RESULT = esr;

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("comparacion",15, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // expresion_sr ::= expresion_sr OPERADOR_SUMA expresion_md 
            {
              Expresion RESULT =null;
		int esrleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).left;
		int esrright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).right;
		Expresion esr = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).value;
		int emdleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int emdright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion emd = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            produccionesRecorridas.add("expresion_sr ->expresion_sr OPERADOR_SUMA expresion_md");
             if(esr.getTipo() == Tipo.INTEGER && emd.getTipo() == Tipo.INTEGER){
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr,emd,Tipo.INTEGER);
                }else{
                    RESULT = new Suma(esr,emd , Tipo.INTEGER);
                };
            }
            else if(esr.getTipo() == Tipo.FLOAT && emd.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(emd);
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr,flotante,Tipo.FLOAT);
                }else{
                    RESULT = new Suma(esr,flotante , Tipo.FLOAT);
                };
            }
            else if(esr.getTipo() == Tipo.INTEGER && emd.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr);
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(flotante,emd,Tipo.FLOAT);
                }else{
                    RESULT = new Suma(flotante,emd, Tipo.FLOAT);
                };
            }
            else if(esr.getTipo() == Tipo.FLOAT && emd.getTipo() == Tipo.FLOAT){
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr,emd,Tipo.FLOAT);
                }else{
                    RESULT = new Suma(esr,emd, Tipo.FLOAT);
                };
            }
            else if(isGuionBajoFilter && (emd.getTipo() == Tipo.FLOAT || emd.getTipo() == Tipo.INTEGER)){
                esr.setTipo(emd.getTipo());
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr,emd,emd.getTipo());
                }else{
                    RESULT = new Suma(esr,emd, emd.getTipo());
                };
            }
            else{
                throw new Exception("No se puede sumar entre una variable de tipo " + Tipo.toString(esr.getTipo()) + " y una variable de tipo " + Tipo.toString(emd.getTipo()));
            }
       
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("expresion_sr",16, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // expresion_sr ::= expresion_sr OPERADOR_RESTA expresion_md 
            {
              Expresion RESULT =null;
		int esrleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).left;
		int esrright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).right;
		Expresion esr = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).value;
		int emdleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int emdright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion emd = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            produccionesRecorridas.add("expresion_sr -> expresion_sr OPERADOR_RESTA expresion_md");
            if(esr.getTipo() == Tipo.INTEGER && emd.getTipo() == Tipo.INTEGER){
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr,emd,Tipo.INTEGER);
                }else{
                    RESULT = new Resta(esr,emd,Tipo.INTEGER);
                };
            }
            else if(esr.getTipo() == Tipo.FLOAT && emd.getTipo() == Tipo.INTEGER){
                EnteroAFlotante flotante = new EnteroAFlotante(emd);
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr,flotante,Tipo.FLOAT);
                }else{
                    RESULT = new Resta(esr,flotante,Tipo.FLOAT);
                };
            }
            else if(esr.getTipo() == Tipo.INTEGER && emd.getTipo() == Tipo.FLOAT){
                EnteroAFlotante flotante = new EnteroAFlotante(esr);
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(flotante,emd,Tipo.FLOAT);
                }else{
                    RESULT = new Resta(flotante,emd,Tipo.FLOAT);
                };
            }
            else if(esr.getTipo() == Tipo.FLOAT && emd.getTipo() == Tipo.FLOAT){
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr,emd,Tipo.FLOAT);
                }else{
                    RESULT = new Resta(esr,emd, Tipo.FLOAT);
                };
            }
            else if(isGuionBajoFilter && (emd.getTipo() == Tipo.FLOAT || emd.getTipo() == Tipo.INTEGER)){
                esr.setTipo(emd.getTipo());
                if (isExpresionFilter){
                    RESULT =new ExpresionFilter(esr,emd,emd.getTipo());
                }else{
                    RESULT = new Resta(esr,emd, emd.getTipo());
                };
            }
            else{
                throw new Exception("No se puede restar entre una variable de tipo " + Tipo.toString(esr.getTipo()) + " y una variable de tipo " + Tipo.toString(emd.getTipo()));
            }
       
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("expresion_sr",16, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // expresion_sr ::= expresion_md 
            {
              Expresion RESULT =null;
		int emdleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int emdright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion emd = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
            produccionesRecorridas.add("expresion_sr -> expresion_md");
            RESULT = emd;

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("expresion_sr",16, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // expresion_md ::= expresion_md OPERADOR_MULTI menos_unario 
            {
              Expresion RESULT =null;
		int emdleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).left;
		int emdright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).right;
		Expresion emd = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).value;
		int muleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int muright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion mu = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("expresion_md -> expresion_md OPERADOR_MULTI menos_unario");
        if(emd.getTipo() == Tipo.INTEGER && mu.getTipo() == Tipo.INTEGER){
            if (isExpresionFilter){
                RESULT =new ExpresionFilter(emd,mu,Tipo.INTEGER);
            }else{
                RESULT = new Multiplicacion(emd,mu, Tipo.INTEGER);
            };
        }
        else if(emd.getTipo() == Tipo.FLOAT && mu.getTipo() == Tipo.INTEGER){
            EnteroAFlotante flotante = new EnteroAFlotante(mu);
            if (isExpresionFilter){
                RESULT =new ExpresionFilter(emd,flotante,Tipo.FLOAT);
            }else{
                RESULT = new Multiplicacion(emd,flotante, Tipo.FLOAT);
            };
        }
        else if(emd.getTipo() == Tipo.INTEGER && mu.getTipo() == Tipo.FLOAT){
            EnteroAFlotante flotante = new EnteroAFlotante(emd);
            if (isExpresionFilter){
                RESULT =new ExpresionFilter(flotante,mu,Tipo.FLOAT);
            }else{
                RESULT = new Multiplicacion(flotante,mu,Tipo.FLOAT);
            };
        }
        else if(emd.getTipo() == Tipo.FLOAT && mu.getTipo() == Tipo.FLOAT){
            if (isExpresionFilter){
                RESULT =new ExpresionFilter(emd,mu,Tipo.FLOAT);
            }else{
                RESULT = new Multiplicacion(emd,mu,Tipo.FLOAT);
            };
        }
        else if(isGuionBajoFilter && (mu.getTipo() == Tipo.FLOAT || mu.getTipo() == Tipo.INTEGER)){
            emd.setTipo(mu.getTipo());
            if (isExpresionFilter){
                RESULT =new ExpresionFilter(emd,mu,mu.getTipo());
            }else{
                RESULT = new Multiplicacion(emd,mu,mu.getTipo());
            };
        }
        else{
            throw new Exception("No se puede multiplicar entre una variable de tipo " + Tipo.toString(emd.getTipo()) + " y una variable de tipo " + Tipo.toString(mu.getTipo()));
        }
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("expresion_md",17, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // expresion_md ::= expresion_md OPERADOR_DIV menos_unario 
            {
              Expresion RESULT =null;
		int emdleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).left;
		int emdright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).right;
		Expresion emd = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).value;
		int muleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int muright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion mu = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("expresion_md -> expresion_md OPERADOR_DIV menos_unario");
        if(emd.getTipo() == Tipo.INTEGER && mu.getTipo() == Tipo.INTEGER){
            if (isExpresionFilter){
                RESULT =new ExpresionFilter(emd,mu,Tipo.INTEGER);
            }else{
                RESULT = new Division(emd,mu, Tipo.INTEGER);
            };
        }
        else if(emd.getTipo() == Tipo.FLOAT && mu.getTipo() == Tipo.INTEGER){
            EnteroAFlotante flotante = new EnteroAFlotante(mu);
            if (isExpresionFilter){
                RESULT =new ExpresionFilter(emd,flotante,Tipo.FLOAT);
            }else{
                RESULT = new Division(emd,flotante, Tipo.FLOAT);
            };
        }
        else if(emd.getTipo() == Tipo.INTEGER && mu.getTipo() == Tipo.FLOAT){
            EnteroAFlotante flotante = new EnteroAFlotante(emd);
            if (isExpresionFilter){
                RESULT =new ExpresionFilter(flotante,mu,Tipo.FLOAT);
            }else{
                RESULT = new Division(flotante,mu, Tipo.FLOAT);
            };
        }
        else if(emd.getTipo() == Tipo.FLOAT && mu.getTipo() == Tipo.FLOAT){
            if (isExpresionFilter){
                RESULT =new ExpresionFilter(emd,mu,Tipo.FLOAT);
            }else{
                RESULT = new Division(emd,mu, Tipo.FLOAT);
            };
        }
        else if(isGuionBajoFilter && (mu.getTipo() == Tipo.FLOAT || mu.getTipo() == Tipo.INTEGER)){
            emd.setTipo(mu.getTipo());
            if (isExpresionFilter){
                RESULT =new ExpresionFilter(emd,mu,mu.getTipo());
            }else{
                RESULT = new Division(emd,mu, mu.getTipo());
            };
        }
        else{
            throw new Exception("No se puede dividir entre una variable de tipo " + Tipo.toString(emd.getTipo()) + " y una variable de tipo " + Tipo.toString(mu.getTipo()));
        }
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("expresion_md",17, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // expresion_md ::= menos_unario 
            {
              Expresion RESULT =null;
		int muleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int muright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion mu = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("expresion_md -> menos_unario");
        RESULT = mu;
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("expresion_md",17, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // menos_unario ::= OPERADOR_RESTA menos_unario 
            {
              Expresion RESULT =null;
		int muleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int muright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion mu = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("menos_unario -> OPERADOR_RESTA menos_unario");
        if(mu.getTipo() == Tipo.INTEGER){
            if (isExpresionFilter){
                RESULT = new ExpresionFilter(new NegacionAritmetica(mu,"sub",Tipo.INTEGER),mu,Tipo.INTEGER);
            }else{
                RESULT = new NegacionAritmetica(mu,"sub",Tipo.INTEGER);
            };
        }else if(mu.getTipo() == Tipo.FLOAT){
            if (isExpresionFilter){
                RESULT = new ExpresionFilter(new NegacionAritmetica(mu,"fsub",Tipo.FLOAT),mu,Tipo.FLOAT);
            }else{
                RESULT =  new NegacionAritmetica(mu,"fsub",Tipo.FLOAT);
            };
        }
        else{
            throw new Exception("No se puede negar una variable de tipo " + Tipo.toString(mu.getTipo()));
        }
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("menos_unario",18, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // menos_unario ::= factor 
            {
              Expresion RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion f = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("menos_unario -> factor");
        RESULT = f;

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("menos_unario",18, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // factor ::= constante 
            {
              Expresion RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Constante c = (Constante)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("factor -> constante");
        isConstante = true;
        RESULT = c;
       
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("factor",19, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // factor ::= filter 
            {
              Expresion RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion f = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("factor -> filter");
        RESULT = f;
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("factor",19, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // factor ::= PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA 
            {
              Expresion RESULT =null;
		int eoleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int eoright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		Expresion eo = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		
        produccionesRecorridas.add("factor -> PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA");
        RESULT = eo;
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("factor",19, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // factor ::= GUION_BAJO 
            {
              Expresion RESULT =null;
		int gbleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int gbright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		String gb = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("factor -> GUION_BAJO");
        isGuionBajoFilter = true;
        RESULT = new GuionBajo();
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("factor",19, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // factor ::= input 
            {
              Expresion RESULT =null;
		int inleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int inright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion in = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("factor ->  input");
        RESULT = in;

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("factor",19, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // constante ::= CONST_BOOL 
            {
              Constante RESULT =null;
		int blleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int blright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		String bl = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("constante -> CONST_BOOL");
        if (isExpresionFilter){
            constantesFilter.add(new Booleano(Boolean.parseBoolean(bl)));
        }
        RESULT = new Booleano(Boolean.parseBoolean(bl));
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("constante",20, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // constante ::= CONST_INT 
            {
              Constante RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		String il = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("constante -> CONST_INT");
        constantesFilter.add(new Entero(Integer.parseInt(il)));
        RESULT = new Entero(Integer.parseInt(il));
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("constante",20, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // constante ::= CONST_FLOAT 
            {
              Constante RESULT =null;
		int flleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int flright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		String fl = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("constante -> CONST_FLOAT");
        
        constantesFilter.add(new Flotante(Float.parseFloat(fl)));
        
        RESULT = new Flotante(Float.parseFloat(fl));
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("constante",20, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // constante ::= STRING_LITERAL 
            {
              Constante RESULT =null;
		int flleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int flright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		String fl = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("constante -> STRING_LITERAL");
        
        constantesFilter.add(new StringLiteral(fl));
        
        RESULT = new StringLiteral(fl);
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("constante",20, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // constante ::= VAR 
            {
              Constante RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("constante -> VAR");
        if(!ht.containsKey(id)){
            throw new VarNotDeclaredTSException("La variable " + id + " no está declarada previamente.");
        }
        Tipo tipoId = ht.get(id);
        RESULT = new Identificador(id, tipoId);
 
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("constante",20, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // NT$1 ::= 
            {
              Expresion RESULT =null;
 isExpresionFilter = true;
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("NT$1",29, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // filter ::= FILTER PARENTESIS_ABRE NT$1 expresion_or COMA CORCHETE_ABRE lista_var CORCHETE_CIERRA PARENTESIS_CIERRA 
            {
              Expresion RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Expresion) ((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-6)).value;
		int e_oleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-5)).left;
		int e_oright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-5)).right;
		Expresion e_o = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-5)).value;
		int l_vleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).left;
		int l_vright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).right;
		ArrayList<String> l_v = (ArrayList<String>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).value;
		
    SentenciaIf sentenciaIf;
    ArrayList<SentenciaElif> sentenciasELIF = new ArrayList<SentenciaElif>();
    ArrayList<Sentencia> sentenciasDentroIF = new ArrayList<>();
    ArrayList<Sentencia> sentenciasDentroELSE = new ArrayList<>();

    Filter filter;
    
    produccionesRecorridas.add("filter -> FILTER PARENTESIS_ABRE expresion_or COMA CORCHETE_ABRE lista_var CORCHETE_CIERRA PARENTESIS_CIERRA");
    
    Tipo tipoIdAsignacion = ht.get(idAsignacionFilter);
    
    System.out.println("e_o.getIdVar(): " + e_o.getIdVar() );

    System.out.println("e_o.getId(): " + e_o.getId() );
    System.out.println("e_o.getNombre(): " + e_o.getNombre() );

    for(int j =0; j < constantesFilter.size(); j++){
        Literal cte = constantesFilter.get(j);
        System.out.println("cte.toString(): " + cte.toString());
    }

    for(int j =0; j < l_v.size(); j++){
        String auxVar = l_v.get(j);
        if(!ht.containsKey(auxVar)){
            throw new VarNotDeclaredTSException("La variable " + auxVar + " no esta declarada previamente\n");
        }else{
            Tipo tipoAuxVar = ht.get(auxVar);
            if(validarTiposVariablesConExpresion(auxVar,e_o)){
                if(isAsignacionFilter==true){
                    if(!validarTiposVariablesConTipoAsignacionId(auxVar)){
                        throw new VarTypeNotCompatibleWithVarListTypes("El Tipo " + Tipo.toString(tipoAuxVar) +  " de la variable "+ auxVar +" no coincide con el Tipo " + tipoIdAsignacion + " de la Asignacion con la variable " + idAsignacionFilter + " \n");
                    }
                }
            }else{
                throw new VarTypeNotEqualWithVarListTypes("El Tipo " + Tipo.toString(tipoAuxVar) +  " de la variable "+ auxVar +" no coincide con el Tipo " + e_o.getTipo() + " de la Expresion \n");
            }

            ArrayList<Sentencia> sentenciasDentroELIF = new ArrayList<>();

            /*
            OperacionFilter expresionFilter = new OperacionFilter(e_o);
            Identificador iden = new Identificador("_",e_o.getTipo());
            iden.setNombreVar("_");
            
            System.out.println("tipoIdAsignacion: " + Tipo.toString(tipoIdAsignacion));
            System.out.println("tipoAuxVar: " + Tipo.toString(tipoAuxVar) );
            System.out.println("auxVar: " + auxVar);
            System.out.println("idAsignacionFilter: " + idAsignacionFilter );




          Constante c;
          if(tipoIdAsignacion == Tipo.INTEGER && tipoAuxVar == Tipo.INTEGER){
              c = new Entero(Integer.parseInt(e_o.getIdVar()));
          }
          else if(tipoIdAsignacion == Tipo.FLOAT || tipoAuxVar == Tipo.INTEGER){
             c = new Flotante(Float.parseFloat(e_o.getIdVar()));
          }else if(tipoIdAsignacion == Tipo.INTEGER || tipoAuxVar == Tipo.FLOAT){
             c = new Flotante(Float.parseFloat(e_o.getIdVar()));
          }else if(tipoIdAsignacion == Tipo.FLOAT && tipoAuxVar == Tipo.FLOAT){
            c = new Flotante(Float.parseFloat(e_o.getIdVar()));
          }else{
            c = new Booleano(Boolean.parseBoolean(e_o.getIdVar()));
          }
            */

            if(j==0){ //si es la primera variable de la lista de variables 
                //if(isAsignacionFilter==true){
                    Asignacion asignacion = new Asignacion(new Identificador(auxVar, tipoAuxVar), e_o); //agrego la asignacion dentro del IF sentencia dentro del IF
                    sentenciasDentroIF.add(asignacion);
                //}
            }else if(j == l_v.size()-1){ //si es la ultima variable de la lista 
                //if(isAsignacionFilter==true){
                    Asignacion asignacion = new Asignacion(new Identificador(auxVar, tipoAuxVar), e_o); //agrego la sentencia dentro del ultimo ELSE
                    sentenciasDentroELSE.add(asignacion); 
                //}
                
            }else{
                //if(isAsignacionFilter==true){
                    Asignacion asignacion = new Asignacion(new Identificador(auxVar, tipoAuxVar), e_o); //agrego la sentencia dentro del  ELIF
                    sentenciasDentroELIF.add(asignacion);
                //}
                sentenciasELIF.add(new SentenciaElif(sentenciasDentroELIF, e_o));
            }
        }
    }

    sentenciaIf = new SentenciaIf(sentenciasDentroIF,e_o,sentenciasELIF, sentenciasDentroELSE);
    
    if(isAsignacionFilter==true){
        filter = new Filter(sentenciaIf, tipoIdAsignacion);
    }else{
        filter = new Filter(sentenciaIf, e_o.getTipo());
    }


    isAsignacionFilter = false;
    isGuionBajoFilter = false;
    isExpresionFilter = false;


    RESULT = filter; 

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("filter",21, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-8)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // sentencia_display ::= DISPLAY PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA 
            {
              Sentencia RESULT =null;
		int eoleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int eoright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		Expresion eo = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		
    produccionesRecorridas.add("sentencia_display -> DISPLAY PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA");
    RESULT = new Display(eo);

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("sentencia_display",10, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-3)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // input ::= input_int 
            {
              Expresion RESULT =null;
		int iileft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int iiright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion ii = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("input -> input_int");
        RESULT = ii;
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("input",12, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // input ::= input_float 
            {
              Expresion RESULT =null;
		int iflleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int iflright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion ifl = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("input -> input_float");
        RESULT = ifl;
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("input",12, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // input ::= input_bool 
            {
              Expresion RESULT =null;
		int ibleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int ibright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion ib = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("input -> input_bool");
        RESULT = ib;

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("input",12, ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // input_int ::= INPUT_INT PARENTESIS_ABRE PARENTESIS_CIERRA 
            {
              Expresion RESULT =null;
		
    produccionesRecorridas.add("input_int -> INPUT_INT PARENTESIS_ABRE PARENTESIS_CIERRA");
    RESULT = new Input(Tipo.INTEGER);

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("input_int",22, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // input_float ::= INPUT_FLOAT PARENTESIS_ABRE PARENTESIS_CIERRA 
            {
              Expresion RESULT =null;
		
    produccionesRecorridas.add("input_float -> INPUT_FLOAT PARENTESIS_ABRE PARENTESIS_CIERRA");
    RESULT = new Input(Tipo.FLOAT);

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("input_float",23, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // input_bool ::= INPUT_BOOL PARENTESIS_ABRE PARENTESIS_CIERRA 
            {
              Expresion RESULT =null;
		
    produccionesRecorridas.add("input_bool -> INPUT_BOOL PARENTESIS_ABRE PARENTESIS_CIERRA");
    RESULT = new Input(Tipo.BOOLEAN);

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("input_bool",24, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // sentencia_if ::= IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias END 
            {
              Sentencia RESULT =null;
		int eoleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-4)).left;
		int eoright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-4)).right;
		Expresion eo = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-4)).value;
		int bsleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int bsright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		ArrayList<Sentencia> bs = (ArrayList<Sentencia>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		
        produccionesRecorridas.add("sentencia_if -> IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias END");
        RESULT = new SentenciaIf(bs,eo);
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("sentencia_if",8, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-6)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // sentencia_if ::= IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias ELSE THEN bloque_sentencias END 
            {
              Sentencia RESULT =null;
		int eoleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-7)).left;
		int eoright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-7)).right;
		Expresion eo = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-7)).value;
		int bs1left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-4)).left;
		int bs1right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-4)).right;
		ArrayList<Sentencia> bs1 = (ArrayList<Sentencia>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-4)).value;
		int bs2left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int bs2right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		ArrayList<Sentencia> bs2 = (ArrayList<Sentencia>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		
        produccionesRecorridas.add("sentencia_if -> IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias ELSE THEN bloque_sentencias END");
        ArrayList<SentenciaElif> sentenciasElif = new ArrayList<>();
        RESULT = new SentenciaIf(bs1,eo, sentenciasElif,bs2);
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("sentencia_if",8, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-9)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // sentencia_if ::= IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias sentencia_elseif END 
            {
              Sentencia RESULT =null;
		int eoleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-5)).left;
		int eoright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-5)).right;
		Expresion eo = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-5)).value;
		int bs1left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).left;
		int bs1right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).right;
		ArrayList<Sentencia> bs1 = (ArrayList<Sentencia>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-2)).value;
		int elseifleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int elseifright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		ArrayList<SentenciaElif> elseif = (ArrayList<SentenciaElif>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		
        produccionesRecorridas.add("sentencia_if -> IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias sentencia_elseif END");
        ArrayList<Sentencia> sentenciasElse = new ArrayList<>();
        RESULT = new SentenciaIf(bs1,eo,elseif, sentenciasElse);
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("sentencia_if",8, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-7)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // sentencia_if ::= IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias sentencia_elseif ELSE THEN bloque_sentencias END 
            {
              Sentencia RESULT =null;
		int eoleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-8)).left;
		int eoright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-8)).right;
		Expresion eo = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-8)).value;
		int bs1left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-5)).left;
		int bs1right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-5)).right;
		ArrayList<Sentencia> bs1 = (ArrayList<Sentencia>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-5)).value;
		int elseifleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-4)).left;
		int elseifright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-4)).right;
		ArrayList<SentenciaElif> elseif = (ArrayList<SentenciaElif>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-4)).value;
		int bs2left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int bs2right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		ArrayList<Sentencia> bs2 = (ArrayList<Sentencia>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		
        produccionesRecorridas.add("sentencia_if -> IF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias sentencia_elseif ELSE THEN bloque_sentencias END");
        RESULT = new SentenciaIf(bs1,eo,elseif, bs2);

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("sentencia_if",8, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-10)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // sentencia_elseif ::= sentencia_elseif ELIF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias 
            {
              ArrayList<SentenciaElif> RESULT =null;
		int elseifleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-6)).left;
		int elseifright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-6)).right;
		ArrayList<SentenciaElif> elseif = (ArrayList<SentenciaElif>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-6)).value;
		int eoleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-3)).left;
		int eoright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-3)).right;
		Expresion eo = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-3)).value;
		int bs2left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int bs2right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		ArrayList<Sentencia> bs2 = (ArrayList<Sentencia>)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("sentencia_elseif -> sentencia_elseif ELIF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias");
        elseif.add(new SentenciaElif(bs2,eo));
        RESULT = elseif;
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("sentencia_elseif",26, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-6)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // sentencia_elseif ::= ELIF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias 
            {
              ArrayList<SentenciaElif> RESULT =null;
		int eoleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-3)).left;
		int eoright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-3)).right;
		Expresion eo = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-3)).value;
		int bs2left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int bs2right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		ArrayList<Sentencia> bs2 = (ArrayList<Sentencia>)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("sentencia_elseif -> ELIF PARENTESIS_ABRE expresion_or PARENTESIS_CIERRA THEN bloque_sentencias");
        ArrayList<SentenciaElif> listaElif = new ArrayList<>();
        listaElif.add(new SentenciaElif(bs2,eo));
        RESULT = listaElif;

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("sentencia_elseif",26, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-5)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // expresion_incremento_decremento ::= OPERADOR_SUMA expresion_sr 
            {
              IncrementoDecrementoFor RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		String op = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		int esr2left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int esr2right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion esr2 = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("expresion_incremento_decremento -> OPERADOR_SUMA expresion_sr");
        RESULT = new IncrementoDecrementoFor(esr2,op,Tipo.INTEGER);
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("expresion_incremento_decremento",25, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // expresion_incremento_decremento ::= OPERADOR_RESTA expresion_sr 
            {
              IncrementoDecrementoFor RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		String op = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		int esr2left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int esr2right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		Expresion esr2 = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("expresion_incremento_decremento -> OPERADOR_RESTA expresion_sr");
        RESULT = new IncrementoDecrementoFor(esr2,op,Tipo.INTEGER);
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("expresion_incremento_decremento",25, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // expresion_incremento_decremento ::= OPERADOR_SUMA OPERADOR_SUMA 
            {
              IncrementoDecrementoFor RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		String op = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		int esr2left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int esr2right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		String esr2 = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("expresion_incremento_decremento -> OPERADOR_SUMA OPERADOR_SUMA");
        RESULT = new IncrementoDecrementoFor(null,op,Tipo.INTEGER);
    
              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("expresion_incremento_decremento",25, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // expresion_incremento_decremento ::= OPERADOR_RESTA OPERADOR_RESTA 
            {
              IncrementoDecrementoFor RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		String op = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		int esr2left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).left;
		int esr2right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()).right;
		String esr2 = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.peek()).value;
		
        produccionesRecorridas.add("expresion_incremento_decremento -> OPERADOR_RESTA OPERADOR_RESTA");
        RESULT = new IncrementoDecrementoFor(null,op,Tipo.INTEGER);

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("expresion_incremento_decremento",25, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // sentencia_for ::= FOR PARENTESIS_ABRE VAR ASIGNACION CONST_INT PUNTO_COMA VAR expresion_incremento_decremento PUNTO_COMA comparacion PARENTESIS_CIERRA DO bloque_sentencias END 
            {
              Sentencia RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-11)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-11)).right;
		String id1 = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-11)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-7)).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-7)).right;
		String id2 = (String)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-7)).value;
		int e_idleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-6)).left;
		int e_idright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-6)).right;
		IncrementoDecrementoFor e_id = (IncrementoDecrementoFor)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-6)).value;
		int c_fleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-4)).left;
		int c_fright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-4)).right;
		Expresion c_f = (Expresion)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-4)).value;
		int bsleft = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).left;
		int bsright = ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).right;
		ArrayList<Sentencia> bs = (ArrayList<Sentencia>)((java_cup.runtime.Symbol) CUP$MiParser$stack.elementAt(CUP$MiParser$top-1)).value;
		
        
    //Verificar que c_f contenga el mismo id que id1 y id2;
    if((id1).equals(id2) && (id1).equals(c_f.getIdVar())){

        //ht.put(id1+'VARIABLE_FOR',Tipo.INTEGER);
        if(!ht.containsKey(id1)){
            throw new VarNotDeclaredTSException("La variable " + id1 + " no está declarada previamente.");
        }
    }else{
        throw new VarForNotEqualException("La variable utlizada en el FOR debe ser la misma");
    }

    //ArrayList<Sentencia> sentencias = new ArrayList<>();
    produccionesRecorridas.add("sentencia_for -> FOR PARENTESIS_ABRE VAR ASIGNACION CONST_INT PUNTO_COMA VAR expresion_incremento_decremento PUNTO_COMA comparacion PARENTESIS_CIERRA DO bloque_sentencias END");
    Asignacion asignacion = new Asignacion(new Identificador(id1,Tipo.INTEGER),e_id);

    is_sentencia_for = false;

   // RESULT = new SentenciaFor(c_f,asignacion,e_id,sentencias);
    RESULT = new SentenciaFor(c_f,asignacion,e_id,bs);

              CUP$MiParser$result = parser.getSymbolFactory().newSymbol("sentencia_for",7, ((java_cup.runtime.Symbol)CUP$MiParser$stack.elementAt(CUP$MiParser$top-13)), ((java_cup.runtime.Symbol)CUP$MiParser$stack.peek()), RESULT);
            }
          return CUP$MiParser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$MiParser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$MiParser$do_action(
    int                        CUP$MiParser$act_num,
    java_cup.runtime.lr_parser CUP$MiParser$parser,
    java.util.Stack            CUP$MiParser$stack,
    int                        CUP$MiParser$top)
    throws java.lang.Exception
    {
              return CUP$MiParser$do_action_part00000000(
                               CUP$MiParser$act_num,
                               CUP$MiParser$parser,
                               CUP$MiParser$stack,
                               CUP$MiParser$top);
    }
}

}
